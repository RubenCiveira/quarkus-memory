/* @autogenerated */
package org.acme.bootstrap.telemetry;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.eclipse.microprofile.config.inject.ConfigProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.enterprise.context.ApplicationScoped;
import lombok.RequiredArgsConstructor;

@ApplicationScoped
@RequiredArgsConstructor
public class LogManagementService {
  private static final String TRACE_TAG = "io.opentelemetry.exporter.logging.LoggingSpanExporter";
  private static final Pattern TRACE_PATTERN = Pattern.compile(
      "'(?<spanName>[^']+)'\\s*:\\s*(?<traceId>[a-f0-9]+)\\s+(?<spanId>[a-f0-9]+)\\s+(?<kind>\\w+)"
  );
  private static final Pattern ATTRIBUTES_PATTERN = 
      Pattern.compile("AttributesMap\\{data=(?<attributes>\\{(?:[^{}]+|\\{.*?\\})*\\})");
  private static final Pattern ATTRIBUTE_PATTERN =
      Pattern.compile("(?<key>[^=,{}]+)=(?<value>\\{[^}]*\\}|\"[^\"]*\"|[^,{}]+)");

  private final @ConfigProperty(name = "quarkus.log.file.path") String logFile;
  private final ObjectMapper objectMapper;

  public List<LogEntry> getLogs(String afterOffset) {
    return readLogs(afterOffset, false);
  }

  public List<LogEntry> getTraces(String afterOffset) {
    return readLogs(afterOffset, true);
  }

  private List<LogEntry> readLogs(String afterOffset, boolean include) {
    List<LogEntry> logs = new ArrayList<>();

    try (BufferedReader reader = new BufferedReader(new FileReader(logFile))) {
      String line;
      while ((line = reader.readLine()) != null) {
        Map<String, Object> logEntryMap =
            objectMapper.readValue(line, new TypeReference<Map<String, Object>>() {});
        Instant timestamp = Instant.parse(logEntryMap.get("timestamp").toString());
        long sequence = Long.parseLong(logEntryMap.get("sequence").toString());

        String offset = timestamp.toString() + "-" + sequence;

        String loggerName = (String) logEntryMap.get("loggerName");
        String message = (String) logEntryMap.get("message");
        if (TRACE_TAG.equals(loggerName) && null != message
            && (message.startsWith("'GET /q/logs'") || message.startsWith("'GET /q/traces'"))) {
          continue;
        }
        if (include && !TRACE_TAG.equals(loggerName)) {
          continue;
        } else if (!include && TRACE_TAG.equals(loggerName)) {
          continue;
        }

        if (include) {
          extractTraceData(message, logEntryMap);
          Map<String, Object> attributes = new HashMap<>();
          extractAttributes(message, attributes);
          logEntryMap.put("attributes", attributes);
        } else {
          extractMdc(logEntryMap);
        }

        if (afterOffset == null || offset.compareTo(afterOffset) > 0) {
          logs.add(LogEntry.builder().offset(offset).data(logEntryMap).build());
        }
      }
    } catch (IOException e) {
      throw new RuntimeException("Error reading log file", e);
    }

    return logs;
  }

  private void extractMdc(Map<String, Object> traceData) {
    @SuppressWarnings("unchecked")
    Map<String, Object> mdc = (Map<String, Object>) traceData.get("mdc");
    if (null != mdc) {
      traceData.put("traceId", mdc.get("traceId"));
      traceData.put("spanId", mdc.get("spanId"));
      if (mdc.containsKey("parentSpanId")) {
        traceData.put("parentSpanId", mdc.get("parentSpanId"));
      }
    }
  }

  private void extractTraceData(String logMessage, Map<String, Object> traceData) {
    Matcher matcher = TRACE_PATTERN.matcher(logMessage);
    if (matcher.find()) {
      traceData.put("spanName", matcher.group("spanName"));
      traceData.put("traceId", matcher.group("traceId"));
      traceData.put("spanId", matcher.group("spanId"));
      traceData.put("kind", matcher.group("kind"));
      
      @SuppressWarnings("unchecked")
      Map<String, Object> mdc = (Map<String, Object>) traceData.get("mdc");
      if (null != mdc) {
        traceData.put("parentSpanId", mdc.get("spanId"));
      }
    }
  }

  public void extractAttributes(String logMessage, Map<String, Object> traceData) {
    Matcher matcher = ATTRIBUTES_PATTERN.matcher(logMessage);
    if (matcher.find()) {
      String rawAttributes = matcher.group("attributes");
      parseAttributes(rawAttributes, traceData);
    }
  }



  private void parseAttributes(String rawAttributes, Map<String, Object> traceData) {
    Matcher matcher = ATTRIBUTE_PATTERN.matcher(rawAttributes);

    while (matcher.find()) {
      String key = matcher.group("key").trim();
      String value = matcher.group("value").trim();
      // Eliminar llaves extra de valores tipo {valor}
      if (value.startsWith("{") && value.endsWith("}")) {
        value = value.substring(1, value.length() - 1);
      }
      // Agregar al mapa
      traceData.put(key, value);
    }

  }
}
