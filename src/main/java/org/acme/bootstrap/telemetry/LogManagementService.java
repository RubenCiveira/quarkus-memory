/* @autogenerated */
package org.acme.bootstrap.telemetry;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.time.Instant;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.eclipse.microprofile.config.inject.ConfigProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.enterprise.context.ApplicationScoped;
import lombok.RequiredArgsConstructor;

@ApplicationScoped
@RequiredArgsConstructor
public class LogManagementService {
  private static final String TRACE_TAG = "io.opentelemetry.exporter.logging.LoggingSpanExporter";
  private static final Pattern TRACE_PATTERN = Pattern.compile(
      "'(?<spanName>[^']+)'\\s*:\\s*(?<traceId>[a-f0-9]+)\\s+(?<spanId>[a-f0-9]+)\\s+(?<kind>\\w+)");
  private static final Pattern ATTRIBUTES_PATTERN =
      Pattern.compile("AttributesMap\\{data=(?<attributes>\\{(?:[^{}]+|\\{.*?\\})*\\})");

  private final @ConfigProperty(name = "quarkus.log.file.path") String logFile;
  private final ObjectMapper objectMapper;

  public List<LogEntry> getLogs(String afterOffset) {
    return readLogs(afterOffset, false);
  }

  public List<LogEntry> getTraces(String afterOffset) {
    return readLogs(afterOffset, true);
  }

  private List<LogEntry> readLogs(String afterOffset, boolean include) {
    List<LogEntry> logs = new ArrayList<>();

    try (BufferedReader reader = new BufferedReader(new FileReader(logFile))) {
      String line;
      while ((line = reader.readLine()) != null) {
        Map<String, Object> logEntryMap =
            objectMapper.readValue(line, new TypeReference<Map<String, Object>>() {});
        Instant timestamp = Instant.parse(logEntryMap.get("timestamp").toString());
        long sequence = Long.parseLong(logEntryMap.get("sequence").toString());

        String offset = timestamp.toString() + "-" + sequence;

        String loggerName = (String) logEntryMap.get("loggerName");
        String message = (String) logEntryMap.get("message");
        if (TRACE_TAG.equals(loggerName) && null != message
            && (message.startsWith("'GET /q/logs'") || message.startsWith("'GET /q/traces'"))) {
          continue;
        }
        if (include && !TRACE_TAG.equals(loggerName)) {
          continue;
        } else if (!include && TRACE_TAG.equals(loggerName)) {
          continue;
        }

        if (include) {
          extractTraceData(message, logEntryMap);
          Map<String, Object> attributes = new HashMap<>();
          extractAttributes(message, attributes);
          logEntryMap.put("attributes", attributes);
        } else {
          extractMdc(logEntryMap);
        }

        if (afterOffset == null || offset.compareTo(afterOffset) > 0) {
          logs.add(LogEntry.builder().offset(offset).data(logEntryMap).build());
        }
      }
    } catch (IOException e) {
      throw new RuntimeException("Error reading log file", e);
    }

    return logs;
  }

  private void extractMdc(Map<String, Object> traceData) {
    @SuppressWarnings("unchecked")
    Map<String, Object> mdc = (Map<String, Object>) traceData.get("mdc");
    if (null != mdc) {
      traceData.put("traceId", mdc.get("traceId"));
      traceData.put("spanId", mdc.get("spanId"));
      if (mdc.containsKey("parentSpanId")) {
        traceData.put("parentSpanId", mdc.get("parentSpanId"));
      }
    }
  }

  private void extractTraceData(String logMessage, Map<String, Object> traceData) {
    Matcher matcher = TRACE_PATTERN.matcher(logMessage);
    if (matcher.find()) {
      traceData.put("spanName", matcher.group("spanName"));
      traceData.put("traceId", matcher.group("traceId"));
      traceData.put("spanId", matcher.group("spanId"));
      traceData.put("kind", matcher.group("kind"));

      @SuppressWarnings("unchecked")
      Map<String, Object> mdc = (Map<String, Object>) traceData.get("mdc");
      if (null != mdc) {
        traceData.put("parentSpanId", mdc.get("spanId"));
      }
    }
  }

  public void extractAttributes(String logMessage, Map<String, Object> traceData) {
    Matcher matcher = ATTRIBUTES_PATTERN.matcher(logMessage);
    if (matcher.find()) {
      String rawAttributes = matcher.group("attributes");
      parseAttributes(rawAttributes.substring(1, rawAttributes.lastIndexOf("}")), traceData);
    }
  }

  // Publis static for testing
  public static void parseAttributes(String rawAttributes, Map<String, Object> attributes) {
    Deque<Character> stack = new ArrayDeque<>();
    StringBuilder keyBuilder = new StringBuilder();
    StringBuilder valueBuilder = new StringBuilder();
    boolean insideQuotes = false;
    boolean parsingValue = true;

    // Recorremos la cadena de DERECHA a IZQUIERDA
    for (int i = rawAttributes.length() - 1; i >= 0; i--) {
      char c = rawAttributes.charAt(i);

      // Manejo de comillas
      if (c == '"' && (stack.isEmpty() || stack.peek() != '\'')) {
        insideQuotes = !insideQuotes;
      }

      if (!insideQuotes) {
        // Manejo de paréntesis y llaves anidadas
        if (c == '}' || c == ')' || c == ']') {
          stack.push(c);
        } else if (c == '{' || c == '(' || c == '[') {
          if (!stack.isEmpty())
            stack.pop();
        }

        // Detectamos la separación entre clave y valor
        if (c == '=' && parsingValue && stack.isEmpty()) {
          parsingValue = false; // Pasamos a leer la clave
          keyBuilder.setLength(0); // Limpiar buffer de clave
          continue;
        }

        // Detectamos una coma solo si NO estamos dentro de una estructura anidada
        if (c == ',' && !parsingValue && stack.isEmpty()) {
          String key = keyBuilder.reverse().toString().trim();
          String value = valueBuilder.reverse().toString().trim(); // Invertir porque se acumuló en
                                                                   // reverso
          value = value.replace("\\\"", "\"").replace("\\\\", "\\");

          attributes.put(key, value);

          valueBuilder.setLength(0); // Limpiar buffer de valor
          parsingValue = true;
          continue;
        }
      }

      // Construimos clave o valor según el estado actual
      if (parsingValue) {
        valueBuilder.append(c);
      } else {
        keyBuilder.append(c);
      }
    }

    // Añadir último par key=value
    if (keyBuilder.length() > 0 && valueBuilder.length() > 0) {
      attributes.put(keyBuilder.reverse().toString().trim(),
          valueBuilder.reverse().toString().replace("\\\"", "\"").replace("\\\\", "\\").trim());
    }
  }
}
