/* @autogenerated */
package org.acme.common.validation;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import org.acme.common.locale.YamlLocaleMessages;
import org.acme.common.validation.AbstractFail.LocalizedFail.LocalizedFailBuilder;

import io.quarkus.runtime.annotations.RegisterForReflection;
import lombok.Builder;
import lombok.Getter;
import lombok.experimental.SuperBuilder;
import lombok.extern.jackson.Jacksonized;

@Getter
@SuperBuilder
@RegisterForReflection
public abstract class AbstractFail {
  @Getter
  @Builder(toBuilder = true)
  @Jacksonized
  @RegisterForReflection
  public static class LocalizedFail {
    private final String code;
    private final String description;
    private final String violation;
    private final List<WrongValue> wrongValues;
  }

  @Getter
  @Builder
  @Jacksonized
  @RegisterForReflection
  public static class LocalizedWrongValue {
    private final String field;
    private final Object wrongValue;
    private final String errorMessage;
  }

  private static Map<Locale, YamlLocaleMessages> localizedMessages;

  private static synchronized YamlLocaleMessages getMessages(Locale locale) {
    if (null == localizedMessages) {
      localizedMessages = new HashMap<>();
    }
    localizedMessages.computeIfAbsent(locale,
        key -> YamlLocaleMessages.load("/messages/errors", key));
    return localizedMessages.get(locale);
  }

  private final String code;
  private final String violation;
  private final List<WrongValue> wrongValues;

  public AbstractFail(String code, String field, Object wrongValue) {
    this.code = code;
    this.violation = null;
    wrongValues = List.of(WrongValue.builder().field(field).wrongValue(wrongValue).build());
  }

  public AbstractFail(String code, String field, Object wrongValue, String errorMessage) {
    this.code = code;
    this.violation = null;
    wrongValues = List.of(WrongValue.builder().field(field).wrongValue(wrongValue)
        .errorMessage(errorMessage).build());
  }

  public AbstractFail(String code, Exception source) {
    this.code = code;
    this.violation = source.getMessage();
    wrongValues = List.of();
  }

  public LocalizedFail localize(Locale locale, boolean withSource) {
    YamlLocaleMessages messages = getMessages(locale);
    LocalizedFailBuilder builder = LocalizedFail.builder()
        .code(messages.contains(code + ".code") ? messages.get(code + ".code") : code);
    if (messages.contains(code + ".description")) {
      builder.description(messages.get(code + ".description"));
    }
    List<LocalizedWrongValue> wrongs = new ArrayList<>();
    for (WrongValue wrongValue : wrongValues) {
      String key = code + ".field." + wrongValue.getField();
      wrongs.add(LocalizedWrongValue.builder().field(wrongValue.getField())
          .wrongValue(wrongValue.getWrongValue())
          .errorMessage(messages.contains(key) ? messages.get(key) : wrongValue.getErrorMessage())
          .build());
    }
    if (withSource && null != violation
        && !"false".equals(messages.get(code + ".show-violation"))) {
      builder = builder.violation(violation);
    }
    return builder.build();
  }
}
