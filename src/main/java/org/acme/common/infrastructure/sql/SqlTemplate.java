/* @autogenerated */
package org.acme.common.infrastructure.sql;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.Optional;

import javax.sql.DataSource;

import io.opentelemetry.api.trace.Span;
import io.opentelemetry.api.trace.SpanKind;
import io.opentelemetry.api.trace.Tracer;
import io.opentelemetry.context.Context;

public class SqlTemplate implements AutoCloseable {
  private final Connection connection;
  private final Tracer tracer;

  // Constructor que recibe la conexión
  public SqlTemplate(Connection connection) {
    if (connection == null) {
      throw new IllegalArgumentException("Connection cannot be null");
    }
    this.connection = connection;
    this.tracer = null;
  }

  // Constructor que recibe la conexión
  public SqlTemplate(DataSource source) {
    if (source == null) {
      throw new IllegalArgumentException("Connection cannot be null");
    }
    try {
      this.connection = source.getConnection();
      this.tracer = null;
    } catch (SQLException ex) {
      throw new UncheckedSqlException(ex);
    }
  }

  // Constructor que recibe la conexión
  public SqlTemplate(Connection connection, Tracer tracer) {
    if (connection == null) {
      throw new IllegalArgumentException("Connection cannot be null");
    }
    this.connection = connection;
    this.tracer = tracer;
  }

  // Constructor que recibe la conexión
  public SqlTemplate(DataSource source, Tracer tracer) {
    if (source == null) {
      throw new IllegalArgumentException("Connection cannot be null");
    }
    try {
      this.connection = source.getConnection();
      this.tracer = tracer;
    } catch (SQLException ex) {
      throw new UncheckedSqlException(ex);
    }
  }

  /**
   * Inicia una transacción configurando auto-commit en false.
   */
  public void begin() {
    try {
      if (connection.getAutoCommit()) {
        connection.setAutoCommit(false);
      }
    } catch (SQLException ex) {
      throw UncheckedSqlException.exception(connection, ex);
    }
  }

  /**
   * Realiza un commit de la transacción actual.
   */
  public void commit() {
    try {
      if (!connection.getAutoCommit()) {
        connection.commit();
        connection.setAutoCommit(true); // Vuelve a habilitar auto-commit
      }
    } catch (SQLException ex) {
      throw UncheckedSqlException.exception(connection, ex);
    }
  }

  /**
   * Realiza un rollback de la transacción actual.
   */
  public void rollback() {
    try {
      if (!connection.getAutoCommit()) {
        connection.rollback();
        connection.setAutoCommit(true); // Vuelve a habilitar auto-commit
      }
    } catch (SQLException ex) {
      throw UncheckedSqlException.exception(connection, ex);
    }
  }

  /**
   * Cierra la conexión.
   */
  public void close() {
    try {
      if (!connection.isClosed()) {
        connection.close();
      }
    } catch (SQLException ex) {
      throw UncheckedSqlException.exception(connection, ex);
    }
  }

  /* default */ Connection currentConnection() {
    return connection;
  }

  /* default */ Optional<Span> createSpan(String title) {
    if (null != tracer) {
      Span parentSpan = Span.current();
      if (parentSpan.getSpanContext().isValid()) {
        return Optional.of(tracer.spanBuilder(title).setParent(Context.current().with(parentSpan))
            .setSpanKind(SpanKind.INTERNAL).startSpan());
      }
    }
    return Optional.empty();
  }

  /* default */ Optional<Span> createSpan(String title, Optional<Span> parent) {
    if (null != tracer && parent.isPresent()) {
      Span parentSpan = parent.get();
      if (parentSpan.getSpanContext().isValid()) {
        return Optional.of(tracer.spanBuilder(title).setParent(Context.current().with(parentSpan))
            .setSpanKind(SpanKind.INTERNAL).startSpan());
      }
    }
    return Optional.empty();
  }

  public <T> SqlSchematicQuery<T> createSqlSchematicQuery(String table) {
    return new SqlSchematicQuery<>(this, table);
  }

  public <T> SqlQuery<T> createSqlQuery(String sql) {
    return new SqlQuery<>(this, sql);
  }

  public SqlCommand createSqlCommand(String sql) {
    return new SqlCommand(this, sql);
  }

}
