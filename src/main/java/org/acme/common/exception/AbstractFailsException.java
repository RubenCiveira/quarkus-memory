/* @autogenerated */
package org.acme.common.exception;

import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.stream.Stream;

import org.acme.common.validation.AbstractFail;
import org.acme.common.validation.AbstractFail.LocalizedFail;
import org.acme.common.validation.AbstractFailList;
import org.acme.common.validation.ConstraintFail;
import org.acme.common.validation.WrongValue;

public abstract class AbstractFailsException extends RuntimeException {

  private static final long serialVersionUID = 261476585734235759L;
  private final AbstractFailList fails;

  public AbstractFailsException(AbstractFailList fails) {
    this.fails = fails;
  }

  public AbstractFailsException(AbstractFail fail) {
    this(new AbstractFailList(fail));
  }

  public boolean hasErrors() {
    return fails.hasErrors();
  }

  public boolean isEmpty() {
    return fails.isEmpty();
  }

  public <T extends ConstraintFail> boolean includeViolation(Class<T> type) {
    return fails.includeViolation(type);
  }

  public boolean includeCode(String code) {
    return fails.includeCode(code);
  }

  public Stream<? extends AbstractFail> getFails() {
    return fails.getFails();
  }

  public Collection<LocalizedFail> localize(Locale locale, boolean withSource) {
    Map<String, LocalizedFail> values = new LinkedHashMap<>();
    fails.getFails().map(fail -> fail.localize(locale, withSource)).forEach(lf -> {
      if (values.containsKey(lf.getCode())) {
        LocalizedFail localizedFail = values.get(lf.getCode());
        List<WrongValue> wrongValues = new ArrayList<>(localizedFail.getWrongValues());
        wrongValues.addAll(lf.getWrongValues());
        values.put(lf.getCode(), localizedFail.toBuilder().wrongValues(wrongValues).build());
      } else {
        values.put(lf.getCode(), lf);
      }
    });
    return values.values();
  }
}
