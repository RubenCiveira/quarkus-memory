/* @autogenerated */
package org.acme.common.batch;

import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Optional;
import java.util.UUID;

import org.acme.common.batch.BatchProgress.GlobalStatus;
import org.acme.common.batch.BatchStepProgress.Status;
import org.acme.common.batch.storage.MasiveOperationStorage;
import org.eclipse.microprofile.context.ManagedExecutor;

import jakarta.enterprise.context.RequestScoped;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RequestScoped
@RequiredArgsConstructor
public class BatchService {
  private final MasiveOperationStorage storage;
  private final ManagedExecutor executor;

  @SuppressWarnings({"rawtypes", "unchecked"})
  public BatchIdentificator start(String actor, Duration preservation, ExecutorPlan<?>... plans) {
    String taskUid = UUID.randomUUID().toString();
    List<BatchStepProgress> map = new ArrayList<>();
    for (int i = 0; i < plans.length; i++) {
      ExecutorPlan<?> plan = plans[i];
      BatchStepProgress step = new BatchStepProgress();
      step.setName(plan.getName());
      step.setStatus(Status.PENDING);
      map.add(step);
    }
    BatchProgress progress = BatchProgress.builder().uid(taskUid).steps(map)
        .startTime(Instant.now()).status(GlobalStatus.PENDING).build();

    storage.save(taskUid, actor, progress);
    executor.runAsync(() -> {
      // We must delay until the http request finish to ensure a new Request Context is build
      sleep("Initial delay to close request context", 5000);
      try {
        for (int i = 0; i < plans.length; i++) {
          ExecutorPlan<?> plan = plans[i];
          Executor task = plan.getExecutor();
          BatchStepProgress massiveOperationResult = map.get(i);
          try {
            massiveOperationResult.setStatus(Status.PROCESSING);
            storage.save(taskUid, actor, progress);
            task.run(massiveOperationResult, t -> {
              storage.save(taskUid, actor, progress);
            }, plan.getParams());
            massiveOperationResult.setStatus(Status.FINISHED);
            storage.save(taskUid, actor, progress);
          } catch (RuntimeException ex) {
            massiveOperationResult.setError(ex.getMessage());
            massiveOperationResult.setStatus(Status.FAILED);
            storage.save(taskUid, actor, progress);
          }
        }
      } finally {
        storage.finish(taskUid, Instant.now().plus(preservation), actor);
      }
    });
    return BatchIdentificator.builder()
        .steps(progress.getSteps().stream().map(BatchStepProgress::getName).toList()).uid(taskUid)
        .build();
  }

  public Optional<BatchProgress> retrieve(String uid, Locale locale, String actor) {
    return storage.restores(uid, actor);
  }

  private void sleep(String label, long time) {
    if (time > 0) {
      try {
        Thread.sleep(time);
      } catch (InterruptedException e) {
        log.error("Interrupt the thread " + label, e);
      }
    }
  }

}
