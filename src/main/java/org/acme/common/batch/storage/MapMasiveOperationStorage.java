/* @autogenerated */
package org.acme.common.batch.storage;

import java.io.IOException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.Duration;
import java.time.Instant;
import java.util.List;
import java.util.Optional;

import javax.sql.DataSource;

import org.acme.common.batch.BatchProgress;
import org.acme.common.batch.BatchProgress.GlobalStatus;
import org.acme.common.batch.BatchStepProgress;
import org.acme.common.batch.BatchStepProgress.Status;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import jakarta.enterprise.context.ApplicationScoped;
import lombok.RequiredArgsConstructor;

@ApplicationScoped
@RequiredArgsConstructor
public class MapMasiveOperationStorage implements MasiveOperationStorage {

  private final DataSource datasource;
  private final ObjectMapper mapper;
  private final Duration timeToLive = Duration.ofDays(3);

  private void cleanTemp(Connection connection) throws SQLException {
    // TODO: add expiration to batch, so every batch could determinate his expiration date.
    try (PreparedStatement updateStatement = connection.prepareStatement(
        "DELETE FROM _long_tasks " + " where completion is not null and completion < ?")) {
      updateStatement.setTimestamp(1,
          new Timestamp(System.currentTimeMillis() - timeToLive.toMillis()));
      updateStatement.executeUpdate();
    }
  }

  @Override
  public void save(String task, String actor, BatchProgress result) {
    try (Connection connection = datasource.getConnection()) {
      cleanTemp(connection);
      try (PreparedStatement prepareStatement = connection
          .prepareStatement("SELECT count(code)  FROM _long_tasks WHERE code = ? and actor=?")) {
        prepareStatement.setString(1, task);
        prepareStatement.setString(2, actor);
        long count = 0;
        try (ResultSet executeQuery = prepareStatement.executeQuery()) {
          if (executeQuery.next()) {
            count = executeQuery.getLong(1);
          }
        }
        if (count == 0) {
          try (PreparedStatement updateStatement = connection.prepareStatement(
              "INSERT INTO _long_tasks (code, actor, creation, progress) VALUES(?, ?, ?, ?)")) {
            updateStatement.setString(1, task);
            updateStatement.setString(2, actor);
            updateStatement.setTimestamp(3, new Timestamp(result.getStartTime().toEpochMilli()));
            updateStatement.setString(4, mapper.writeValueAsString(result.getSteps()));
            if (updateStatement.executeUpdate() != 1) {
              throw new IllegalArgumentException("Imposible crear para " + task);
            }
          }
        } else {
          try (PreparedStatement updateStatement = connection
              .prepareStatement("UPDATE _long_tasks set progress = ? where code=? and actor=?")) {
            updateStatement.setString(1, mapper.writeValueAsString(result.getSteps()));
            updateStatement.setString(2, task);
            updateStatement.setString(3, actor);
            if (updateStatement.executeUpdate() != 1) {
              throw new IllegalArgumentException("Imposible crear para " + task);
            }
          }
        }
      }
    } catch (JsonProcessingException | SQLException e) {
      throw new IllegalArgumentException(e);
    }
  }

  @Override
  public Optional<BatchProgress> restores(String task, String actor) {
    Optional<BatchProgress> result = Optional.empty();
    try (Connection connection = datasource.getConnection()) {
      cleanTemp(connection);
      try (PreparedStatement prepareStatement = connection.prepareStatement(
          "SELECT progress, creation, completion  FROM _long_tasks WHERE code = ? and actor=?")) {
        prepareStatement.setString(1, task);
        prepareStatement.setString(2, actor);
        try (ResultSet executeQuery = prepareStatement.executeQuery()) {
          if (executeQuery.next()) {
            String json = executeQuery.getString(1);
            List<BatchStepProgress> steps =
                mapper.readValue(json, new TypeReference<List<BatchStepProgress>>() {});
            result = Optional.of(BatchProgress.builder().uid(task).status(globalStatus(steps))
                .startTime(Instant.ofEpochMilli(executeQuery.getTimestamp(2).getTime()))
                .endTime(null == executeQuery.getTimestamp(3) ? null
                    : Instant.ofEpochMilli(executeQuery.getTimestamp(3).getTime()))
                .steps(steps).build());
          }
        }
      }
    } catch (IOException | SQLException e) {
      throw new IllegalArgumentException(e);
    }
    return result;
  }

  @Override
  public void finish(String taskUid, String actor) {
    try (Connection connection = datasource.getConnection()) {
      cleanTemp(connection);
      try (PreparedStatement updateStatement = connection
          .prepareStatement("UPDATE _long_tasks SET completion = ? where code = ? and actor = ?")) {
        updateStatement.setTimestamp(1, new Timestamp(System.currentTimeMillis()));
        updateStatement.setString(2, taskUid);
        updateStatement.setString(3, actor);
        if (updateStatement.executeUpdate() != 1) {
          throw new IllegalArgumentException("Imposible cerrar para " + taskUid);
        }
      }
    } catch (SQLException e) {
      throw new IllegalArgumentException(e);
    }
  }

  private GlobalStatus globalStatus(List<BatchStepProgress> steps) {
    GlobalStatus status = GlobalStatus.PENDING;
    boolean someProcesing = false;
    boolean someError = false;
    boolean allPending = true;

    for (BatchStepProgress massiveOperationResultDetail : steps) {
      if (massiveOperationResultDetail.getStatus() == Status.PROCESSING) {
        someProcesing = true;
        allPending = false;
      } else if (massiveOperationResultDetail.getStatus() == Status.FAILED) {
        someError = true;
        allPending = false;
      } else if (massiveOperationResultDetail.getStatus() == Status.FINISHED) {
        allPending = false;
      }
    }
    if (allPending) {
      status = GlobalStatus.PENDING;
    } else if (someProcesing) {
      status = GlobalStatus.PROCESSING;
    } else if (someError) {
      status = GlobalStatus.FAILED;
    } else {
      status = GlobalStatus.FINISHED;
    }
    return status;
  }

}
