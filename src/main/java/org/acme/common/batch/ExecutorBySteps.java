/* @autogenerated */
package org.acme.common.batch;

import java.util.ArrayList;
import java.util.List;

import org.acme.common.exception.AbstractFailsException;
import org.acme.common.validation.ExecutionFail;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public abstract class ExecutorBySteps<T, R, P> implements Executor<P> {
  private long readSleep = 100;
  private long processSleep = 100;
  private long writeSleep = 100;
  private int bufferSize = 10;

  @Override
  public void run(BatchStepProgress result, Monitor store, P param) {
    List<Object[]> results = new ArrayList<>();

    List<T> items = read(result, store, param);
    for (T item : items) {
      R processed = process(item, result, store, param);
      if (null != processed) {
        results.add(new Object[] {item, processed});
      }
      if (results.size() == bufferSize) {
        write(results, result, store, param);
      }
    }
    write(results, result, store, param);
    finish(param);
  }

  protected abstract List<T> read(P param);

  @SuppressWarnings("unchecked")
  protected R process(T item, P param) {
    return (R) item;
  }

  protected void finish(P param) {}

  protected String itemDescriptor(T input) {
    return input.toString();
  }

  protected abstract void write(R item, P param);

  private List<T> read(BatchStepProgress result, Monitor store, P param) {
    List<T> items = read(param);
    result.setTotalItems(items.size());
    store.updateState(result);
    sleep("after read items", readSleep);
    return items;
  }

  private R process(T item, BatchStepProgress result, Monitor store, P param) {
    String ref = itemDescriptor(item);
    try {
      R processed = process(item, param);
      sleep("after process items", processSleep);
      return processed;
    } catch (AbstractFailsException ex) {
      ex.getFails().forEach(fail -> result.addError(ref, fail));
      store.updateState(result);
      return null;
    } catch (Exception ex) {
      result.addError(ref, new ExecutionFail(ex.getClass().getName(), ex.getMessage()));
      store.updateState(result);
      return null;
    }
  }

  @SuppressWarnings("unchecked")
  private void write(List<Object[]> items, BatchStepProgress result, Monitor store, P param) {
    for (Object[] rows : items) {
      T input = (T) rows[0];
      R output = (R) rows[1];
      String ref = itemDescriptor(input);
      try {
        write(output, param);
        result.addOk(ref);
      } catch (AbstractFailsException ex) {
        ex.getFails().forEach(fail -> result.addError(ref, fail));
      } catch (Exception ex) {
        result.addError(ref, new ExecutionFail(ex.getClass().getName(), ex.getMessage()));
      }
      store.updateState(result);
      sleep("after write items", writeSleep);
    }
    items.clear();
  }

  private void sleep(String label, long time) {
    if (time > 0) {
      try {
        Thread.sleep(time);
      } catch (InterruptedException e) {
        log.error("Interrupt the thread " + label, e);
      }
    }
  }
}
