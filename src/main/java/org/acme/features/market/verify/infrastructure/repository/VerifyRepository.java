package org.acme.features.market.verify.infrastructure.repository;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import java.util.function.Function;

import javax.sql.DataSource;

import org.acme.common.action.Slide;
import org.acme.common.exception.ConstraintException;
import org.acme.common.exception.NotFoundException;
import org.acme.common.sql.OptimistLockException;
import org.acme.common.sql.PartialWhere;
import org.acme.common.sql.SqlCommand;
import org.acme.common.sql.SqlConverter;
import org.acme.common.sql.SqlListParameterValue;
import org.acme.common.sql.SqlOperator;
import org.acme.common.sql.SqlParameterValue;
import org.acme.common.sql.SqlQuery;
import org.acme.common.sql.SqlSchematicQuery;
import org.acme.common.sql.SqlTemplate;
import org.acme.features.market.verify.domain.gateway.VerifyCursor;
import org.acme.features.market.verify.domain.gateway.VerifyFilter;
import org.acme.features.market.verify.domain.gateway.VerifyOrder;
import org.acme.features.market.verify.domain.model.Verify;
import org.acme.features.market.verify.domain.model.VerifyMedal;
import org.acme.features.market.verify.domain.model.VerifyRef;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@RequiredArgsConstructor
@Slf4j
public class VerifyRepository {

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private final DataSource datasource;

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @return
   */
  public CompletionStage<Optional<Verify>> create(Verify entity) {
    return runCreate(entity, null);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @param verifier
   * @return
   */
  public CompletionStage<Optional<Verify>> create(Verify entity,
      Function<Verify, CompletionStage<Boolean>> verifier) {
    return runCreate(entity, verifier);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @return
   */
  public CompletionStage<Verify> delete(Verify entity) {
    return CompletableFuture.allOf(deleteMedals(entity, entity.getMedalsValue()))
        .thenCompose(_void -> {
          try (SqlTemplate template = new SqlTemplate(datasource)) {
            SqlCommand sq =
                template.createSqlCommand("delete from \"verify\" where \"uid\" = :uid");
            sq.with("uid", SqlParameterValue.of(entity.getUidValue()));
            return sq.execute().thenApply(num -> {
              if (0 == num) {
                throw new IllegalArgumentException("No delete from");
              }
              return entity;
            });
          }
        });
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param reference
   * @return
   */
  public CompletionStage<Verify> enrich(VerifyRef reference) {
    return reference instanceof Verify ? CompletableFuture.completedStage((Verify) reference)
        : retrieve(reference.getUidValue(), Optional.empty())
            .thenApply(optional -> optional.orElseThrow(() -> new NotFoundException(
                "Trying to enrich inexistent Verify: " + reference.getUidValue())));
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param uid
   * @param filter
   * @return
   */
  public CompletionStage<Boolean> exists(String uid, Optional<VerifyFilter> filter) {
    return retrieve(uid, filter).thenApply(Optional::isPresent);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @param cursor
   * @return
   */
  public CompletionStage<Slide<Verify>> list(VerifyFilter filter, VerifyCursor cursor) {
    try (SqlTemplate template = new SqlTemplate(datasource)) {
      SqlSchematicQuery<Verify> sq = filteredQuery(template, filter);
      PartialWhere offset = PartialWhere.empty();
      PartialWhere prev = PartialWhere.empty();
      if (null != cursor.getOrder()) {
        for (VerifyOrder order : cursor.getOrder()) {
          if (order == VerifyOrder.NAME_ASC) {
            sq.orderAsc("name");
            Optional<String> sinceName = cursor.getSinceName();
            if (sinceName.isPresent()) {
              String sinceNameValue = sinceName.get();
              offset = PartialWhere.or(offset, PartialWhere.and(prev, PartialWhere.where("name",
                  SqlOperator.GT, SqlParameterValue.of(sinceNameValue))));
              prev = PartialWhere.and(prev,
                  PartialWhere.where("name", SqlOperator.EQ, SqlParameterValue.of(sinceNameValue)));
            }
          }
          if (order == VerifyOrder.NAME_DESC) {
            sq.orderDesc("name");
            Optional<String> sinceName = cursor.getSinceName();
            if (sinceName.isPresent()) {
              String sinceNameValue = sinceName.get();
              offset = PartialWhere.or(offset, PartialWhere.and(prev, PartialWhere.where("name",
                  SqlOperator.GT, SqlParameterValue.of(sinceNameValue))));
              prev = PartialWhere.and(prev,
                  PartialWhere.where("name", SqlOperator.EQ, SqlParameterValue.of(sinceNameValue)));
            }
          }
        }
        Optional<String> sinceUid = cursor.getSinceUid();
        if (sinceUid.isPresent()) {
          offset = PartialWhere.or(offset, PartialWhere.and(prev,
              PartialWhere.where("uid", SqlOperator.GT, SqlParameterValue.of(sinceUid.get()))));
        }
        sq.where(offset);
      } else {
        cursor.getSinceUid()
            .ifPresent(since -> sq.where("uid", SqlOperator.GT, SqlParameterValue.of(since)));
      }
      sq.orderAsc("uid");
      return sq.query(converter()).limit(cursor.getLimit())
          .thenApply(res -> new VerifySlice(cursor.getLimit(), res, this::list, filter, cursor));
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param uid
   * @param filter
   * @return
   */
  public CompletionStage<Optional<Verify>> retrieve(String uid, Optional<VerifyFilter> filter) {
    try (SqlTemplate template = new SqlTemplate(datasource)) {
      VerifyFilter readyFilter = filter.map(val -> val.withUid(uid))
          .orElseGet(() -> VerifyFilter.builder().uid(uid).build());
      SqlSchematicQuery<Verify> sq = filteredQuery(template, readyFilter);
      return sq.query(converter()).one();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @return
   */
  public CompletionStage<Verify> update(Verify entity) {
    try (SqlTemplate template = new SqlTemplate(datasource)) {
      int version = entity.getVersionValue().orElse(0);
      SqlCommand sq = template.createSqlCommand(
          "update \"verify\" set  \"name\" = :name, \"version\" = \"version\" + 1 where \"uid\" = :uid and \"version\" = :version");
      sq.with("uid", SqlParameterValue.of(entity.getUidValue()));
      sq.with("name", SqlParameterValue.of(entity.getNameValue()));
      sq.with("version", entity.getVersionValue().map(SqlParameterValue::of)
          .orElseGet(SqlParameterValue::ofNullInteger));
      return sq.execute().thenApply(num -> {
        if (0 == num) {
          throw new OptimistLockException("No delete from");
        }
        return entity.withVersionValue(version + 1);
      }).thenCompose(updated -> {
        List<VerifyMedal> medalsValue = new ArrayList<>();
        return CompletableFuture
            .allOf(saveMedals(updated, updated.getMedalsValue()).thenApply(medalsValue::addAll))
            .thenApply(_void -> updated.withMedalsValue(medalsValue));
      });
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @return
   */
  private SqlConverter<Verify> converter() {
    return (row) -> {
      try {
        List<VerifyMedal> medalsFromChilds = new ArrayList<>();
        CompletionStage<List<VerifyMedal>> childs = row.getChilds("medals");
        childs.whenComplete((childlist, fail) -> medalsFromChilds.addAll(childlist));
        return Optional.of(Verify.builder().uidValue(row.getString(1)).nameValue(row.getString(2))
            .medalsValue(medalsFromChilds).versionValue(row.getInt(3)).build());
      } catch (ConstraintException ce) {
        log.error("Unable to map data for {}", row.getString(1), ce);
        return Optional.empty();
      }
    };
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @param childs
   * @return
   */
  private CompletableFuture<Void> deleteMedals(Verify entity, List<VerifyMedal> childs) {
    try (SqlTemplate template = new SqlTemplate(datasource)) {
      SqlCommand sq =
          template.createSqlCommand("delete from \"verify_medal\" where \"verify\" = :verify");
      sq.with("verify", SqlParameterValue.of(entity.getUidValue()));
      return sq.execute().toCompletableFuture().thenApply(val -> null);
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param template
   * @param filter
   * @return
   */
  private SqlSchematicQuery<Verify> filteredQuery(SqlTemplate template, VerifyFilter filter) {
    SqlSchematicQuery<Verify> sq = template.createSqlSchematicQuery("verify");
    sq.select("verify.uid", "verify.name", "verify.version");
    sq.child(100, "medals",
        "select \"verify\",\"uid\",\"medal\",\"version\" from \"verify_medal\"  where \"verify\" in (:verify)",
        "uid", "verify", row -> {
          try {
            return Optional.of(VerifyMedal.builder().uidValue(row.getString(2))
                .medalReferenceValue(row.getString(3)).versionValue(row.getInt(4)).build());
          } catch (ConstraintException ce) {
            log.error("Unable to map medals child data for {}", row.getString(2), ce);
            return Optional.empty();
          }
        });
    filter.getUid().ifPresent(uid -> sq.where("uid", SqlOperator.EQ, SqlParameterValue.of(uid)));
    if (!filter.getUids().isEmpty()) {
      sq.where("uid", SqlOperator.IN, SqlListParameterValue.strings(filter.getUids()));
    }
    filter.getSearch().ifPresent(
        search -> sq.where("name", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%")));
    filter.getName()
        .ifPresent(name -> sq.where("name", SqlOperator.EQ, SqlParameterValue.of(name)));
    return sq;
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @param verifier
   * @return
   */
  private CompletionStage<Optional<Verify>> runCreate(Verify entity,
      Function<Verify, CompletionStage<Boolean>> verifier) {
    try (SqlTemplate template = new SqlTemplate(datasource)) {
      SqlCommand sq = template.createSqlCommand(
          "insert into \"verify\" ( \"uid\", \"name\", \"version\") values ( :uid, :name, :version)");
      sq.with("uid", SqlParameterValue.of(entity.getUidValue()));
      sq.with("name", SqlParameterValue.of(entity.getNameValue()));
      sq.with("version", entity.getVersionValue().map(SqlParameterValue::of)
          .orElseGet(SqlParameterValue::ofNullInteger));
      return sq.execute().thenCompose(num -> {
        if (0 == num) {
          throw new IllegalArgumentException("No insert into");
        }
        return (verifier == null ? CompletableFuture.completedFuture(Optional.of(entity))
            : verifier.apply(entity).thenCompose(exists -> {
              if (exists) {
                return CompletableFuture.completedFuture(Optional.of(entity));
              } else {
                template.createSqlCommand("delete from \"verify\" where \"uid\" = :uid")
                    .with("uid", SqlParameterValue.of(entity.getUidValue())).execute();
                return CompletableFuture.completedFuture(Optional.<Verify>empty());
              }
            }));
      }).thenCompose(created -> {
        if (created.isPresent()) {
          Verify entityVal = created.get();
          List<VerifyMedal> medalsValue = new ArrayList<>();
          return CompletableFuture
              .allOf(
                  saveMedals(entityVal, entityVal.getMedalsValue()).thenApply(medalsValue::addAll))
              .thenApply(_void -> Optional.of(entityVal.withMedalsValue(medalsValue)));
        } else {
          return CompletableFuture.completedFuture(Optional.empty());
        }
      });
    }
  }

  /**
   * verify
   *
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @param childs
   * @return verify
   */
  private CompletableFuture<List<VerifyMedal>> saveMedals(Verify entity, List<VerifyMedal> childs) {
    try (SqlTemplate template = new SqlTemplate(datasource)) {
      SqlQuery<Object[]> sq = template.createSqlQuery(
          "select \"uid\", \"verify\" from \"verify_medal\" where (\"verify\" = :verify)"
              + " or ( \"uid\" in (:tomap) and \"verify\" != :verify )");
      sq.with("verify", SqlParameterValue.of(entity.getUidValue()));
      sq.with("tomap", SqlListParameterValue
          .strings(childs.stream().map(child -> child.getUidValue()).toList()));
      return sq.query(row -> Optional.of(new Object[] {row.getString(1), row.getString(2)})).all()
          .thenCompose(list -> {
            if (list.stream().anyMatch(arr -> !entity.getUidValue().equals(arr[1]))) {
              throw new IllegalArgumentException("Try to move from another parent");
            }
            List<VerifyMedal> response = new ArrayList<>();
            List<String> codes =
                new ArrayList<>(list.stream().map(arr -> (String) arr[0]).toList());
            List<CompletableFuture<?>> removes = new ArrayList<>();
            List<CompletableFuture<?>> writes = new ArrayList<>();
            childs.forEach(child -> {
              SqlCommand command = template.createSqlCommand(codes.contains(child.getUidValue())
                  ? "update \"verify_medal\" set \"verify\" = :verify, \"medal\" = :medal, \"version\" = \"version\" + 1 where \"uid\" = :uid and \"version\" = :version"
                  : "insert into \"verify_medal\" ( \"uid\", \"verify\", \"medal\", \"version\") values ( :uid, :verify, :medal, :version)");
              command.with("uid", SqlParameterValue.of(child.getUidValue()));
              command.with("verify", SqlParameterValue.of(entity.getUidValue()));
              command.with("medal", SqlParameterValue.of(child.getMedalReferenceValue()));
              command.with("version", child.getVersionValue().map(SqlParameterValue::of)
                  .orElseGet(SqlParameterValue::ofNullInteger));
              codes.remove(child.getUidValue());
              writes.add(command.execute().toCompletableFuture().whenComplete((val, fail) -> {
                if (val != 1) {
                  throw new OptimistLockException("No child processed");
                } else {
                  response.add(child.withVersionValue(child.getVersionValue().orElse(0) + 1));
                }
              }));
            });
            if (!codes.isEmpty()) {
              SqlCommand deleted = template
                  .createSqlCommand("delete from\"verify_medal\" where \"uid\" in (:codes)");
              deleted.with("codes", SqlListParameterValue.strings(codes));
              removes.add(deleted.execute().toCompletableFuture());
            }
            // First, remove all to delete to make space, After remove we append the write changes.
            return CompletableFuture.allOf(removes.toArray(new CompletableFuture[0]))
                .thenCompose(
                    _void -> CompletableFuture.allOf(writes.toArray(new CompletableFuture[0])))
                .thenApply(_void -> response);
          }).toCompletableFuture();
    }
  }
}
