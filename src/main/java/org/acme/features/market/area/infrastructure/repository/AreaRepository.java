package org.acme.features.market.area.infrastructure.repository;

import java.util.Iterator;
import java.util.Optional;
import java.util.function.Function;

import javax.sql.DataSource;

import org.acme.common.algorithms.Slider;
import org.acme.common.exception.ConstraintException;
import org.acme.common.exception.NotFoundException;
import org.acme.common.infrastructure.sql.OptimistLockException;
import org.acme.common.infrastructure.sql.PartialWhere;
import org.acme.common.infrastructure.sql.SqlCommand;
import org.acme.common.infrastructure.sql.SqlConverter;
import org.acme.common.infrastructure.sql.SqlListParameterValue;
import org.acme.common.infrastructure.sql.SqlOperator;
import org.acme.common.infrastructure.sql.SqlParameterValue;
import org.acme.common.infrastructure.sql.SqlSchematicQuery;
import org.acme.common.infrastructure.sql.SqlTemplate;
import org.acme.features.market.area.domain.gateway.AreaCursor;
import org.acme.features.market.area.domain.gateway.AreaFilter;
import org.acme.features.market.area.domain.gateway.AreaOrder;
import org.acme.features.market.area.domain.model.Area;
import org.acme.features.market.area.domain.model.AreaRef;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@RequiredArgsConstructor
@Slf4j
public class AreaRepository {

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private final DataSource datasource;

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @return
   */
  public long count(AreaFilter filter) {
    try (SqlTemplate template = new SqlTemplate(datasource)) {
      SqlSchematicQuery<Long> sq = filteredQuery(template, filter);
      sq.select("count(uid) as uid");
      return sq.query(row -> {
        return Optional.of(row.getLong(1));
      }).one().orElse(0l);
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @return
   */
  public Area create(Area entity) {
    return runCreate(entity, null);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @param verifier
   * @return
   */
  public Area create(Area entity, Function<Area, Boolean> verifier) {
    return runCreate(entity, verifier);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @return
   */
  public Area delete(Area entity) {
    try (SqlTemplate template = new SqlTemplate(datasource)) {
      SqlCommand sq = template.createSqlCommand("delete from \"area\" where \"uid\" = :uid");
      sq.with("uid", SqlParameterValue.of(entity.getUidValue()));
      int num = sq.execute();
      if (0 == num) {
        throw new IllegalArgumentException("No delete from");
      }
      return entity;
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param reference
   * @return
   */
  public Area enrich(AreaRef reference) {
    return reference instanceof Area ? (Area) reference
        : retrieve(reference.getUidValue(), Optional.empty())
            .orElseThrow(() -> new NotFoundException(
                "Trying to enrich inexistent Area: " + reference.getUidValue()));
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param uid
   * @param filter
   * @return
   */
  public boolean exists(String uid, Optional<AreaFilter> filter) {
    return retrieve(uid, filter).isPresent();
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @param cursor
   * @return
   */
  public Slider<Area> list(AreaFilter filter, AreaCursor cursor) {
    return new AreaSlider(runList(filter, cursor), cursor.getLimit().orElse(0), this::runList,
        filter, cursor);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param uid
   * @param filter
   * @return
   */
  public Optional<Area> retrieve(String uid, Optional<AreaFilter> filter) {
    try (SqlTemplate template = new SqlTemplate(datasource)) {
      AreaFilter readyFilter = filter.map(val -> val.withUid(uid))
          .orElseGet(() -> AreaFilter.builder().uid(uid).build());
      SqlSchematicQuery<Area> sq = filteredQuery(template, readyFilter);
      return sq.query(converter()).one();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @return
   */
  public Area update(Area entity) {
    try (SqlTemplate template = new SqlTemplate(datasource)) {
      int version = entity.getVersionValue().orElse(0);
      SqlCommand sq = template.createSqlCommand(
          "update \"area\" set  \"name\" = :name, \"place\" = :place, \"version\" = \"version\" + 1 where \"uid\" = :uid and \"version\" = :version");
      sq.with("uid", SqlParameterValue.of(entity.getUidValue()));
      sq.with("name", SqlParameterValue.of(entity.getNameValue()));
      sq.with("place", SqlParameterValue.of(entity.getPlaceReferenceValue()));
      sq.with("version", entity.getVersionValue().map(SqlParameterValue::of)
          .orElseGet(SqlParameterValue::ofNullInteger));
      int num = sq.execute();
      if (0 == num) {
        throw new OptimistLockException("No delete from");
      }
      return entity.withVersionValue(version + 1);
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @return
   */
  private SqlConverter<Area> converter() {
    return (row) -> {
      try {
        return Optional.of(Area.builder().uidValue(row.getString(1)).nameValue(row.getString(2))
            .placeReferenceValue(row.getString(3)).versionValue(row.getInt(4)).build());
      } catch (ConstraintException ce) {
        log.error("Unable to map data for {}", row.getString(1), ce);
        return Optional.empty();
      }
    };
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param template
   * @param filter
   * @return
   */
  private <T> SqlSchematicQuery<T> filteredQuery(SqlTemplate template, AreaFilter filter) {
    SqlSchematicQuery<T> sq = template.createSqlSchematicQuery("area");
    sq.selectFields("area.uid", "area.name", "area.place", "area.version");
    filter.getUid().ifPresent(uid -> sq.where("uid", SqlOperator.EQ, SqlParameterValue.of(uid)));
    if (!filter.getUids().isEmpty()) {
      sq.where("uid", SqlOperator.IN, SqlListParameterValue.strings(filter.getUids()));
    }
    filter.getSearch().ifPresent(
        search -> sq.where("name", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%")));
    filter.getName()
        .ifPresent(name -> sq.where("name", SqlOperator.EQ, SqlParameterValue.of(name)));
    filter.getPlace().ifPresent(
        place -> sq.where("place", SqlOperator.EQ, SqlParameterValue.of(place.getUidValue())));
    if (!filter.getPlaces().isEmpty()) {
      sq.where("place", SqlOperator.IN, SqlListParameterValue.strings(filter.getPlaces()));
    }
    filter.getPlaceMerchantMerchantAccesible().ifPresent(placeMerchantMerchantAccesible -> {
      sq.join("place", "area_place", "area.place", "area_place.uid");
      sq.where("area_place.merchant", SqlOperator.EQ,
          SqlParameterValue.of(placeMerchantMerchantAccesible));
    });
    return sq;
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @param verifier
   * @return
   */
  private Area runCreate(Area entity, Function<Area, Boolean> verifier) {
    try (SqlTemplate template = new SqlTemplate(datasource)) {
      SqlCommand sq = template.createSqlCommand(
          "insert into \"area\" ( \"uid\", \"name\", \"place\", \"version\") values ( :uid, :name, :place, :version)");
      sq.with("uid", SqlParameterValue.of(entity.getUidValue()));
      sq.with("name", SqlParameterValue.of(entity.getNameValue()));
      sq.with("place", SqlParameterValue.of(entity.getPlaceReferenceValue()));
      sq.with("version", entity.getVersionValue().map(SqlParameterValue::of)
          .orElseGet(SqlParameterValue::ofNullInteger));
      int num = sq.execute();
      if (0 == num) {
        throw new IllegalArgumentException("No insert into");
      }
      return verifier == null ? entity : verified(verifier.apply(entity), entity, template);
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @param cursor
   * @return
   */
  private Iterator<Area> runList(AreaFilter filter, AreaCursor cursor) {
    try (SqlTemplate template = new SqlTemplate(datasource)) {
      SqlSchematicQuery<Area> sq = filteredQuery(template, filter);
      PartialWhere offset = PartialWhere.empty();
      PartialWhere prev = PartialWhere.empty();
      if (null != cursor.getOrder()) {
        for (AreaOrder order : cursor.getOrder()) {
          if (order == AreaOrder.NAME_ASC) {
            sq.addOrderAsc("name");
            Optional<String> sinceName = cursor.getSinceName();
            if (sinceName.isPresent()) {
              String sinceNameValue = sinceName.get();
              offset = PartialWhere.or(offset, PartialWhere.and(prev, PartialWhere.where("name",
                  SqlOperator.GT, SqlParameterValue.of(sinceNameValue))));
              prev = PartialWhere.and(prev,
                  PartialWhere.where("name", SqlOperator.EQ, SqlParameterValue.of(sinceNameValue)));
            }
          }
          if (order == AreaOrder.NAME_DESC) {
            sq.addOrderDesc("name");
            Optional<String> sinceName = cursor.getSinceName();
            if (sinceName.isPresent()) {
              String sinceNameValue = sinceName.get();
              offset = PartialWhere.or(offset, PartialWhere.and(prev, PartialWhere.where("name",
                  SqlOperator.GT, SqlParameterValue.of(sinceNameValue))));
              prev = PartialWhere.and(prev,
                  PartialWhere.where("name", SqlOperator.EQ, SqlParameterValue.of(sinceNameValue)));
            }
          }
        }
        Optional<String> sinceUid = cursor.getSinceUid();
        if (sinceUid.isPresent()) {
          offset = PartialWhere.or(offset, PartialWhere.and(prev,
              PartialWhere.where("uid", SqlOperator.GT, SqlParameterValue.of(sinceUid.get()))));
        }
        sq.where(offset);
      } else {
        cursor.getSinceUid()
            .ifPresent(since -> sq.where("uid", SqlOperator.GT, SqlParameterValue.of(since)));
      }
      sq.orderAsc("uid");
      return sq.query(converter()).limit(cursor.getLimit()).iterator();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param exists
   * @param entity
   * @param template
   * @return
   */
  private Area verified(Boolean exists, Area entity, SqlTemplate template) {
    if (exists) {
      return entity;
    } else {
      template.createSqlCommand("delete from \"area\" where \"uid\" = :uid")
          .with("uid", SqlParameterValue.of(entity.getUidValue())).execute();
      throw new NotFoundException("");
    }
  }
}
