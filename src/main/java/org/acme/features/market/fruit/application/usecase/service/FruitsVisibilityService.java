package org.acme.features.market.fruit.application.usecase.service;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Stream;

import org.acme.common.action.Interaction;
import org.acme.features.market.fruit.application.interaction.FruitDto;
import org.acme.features.market.fruit.domain.Fruits;
import org.acme.features.market.fruit.domain.gateway.FruitFilter;
import org.acme.features.market.fruit.domain.model.Fruit;
import org.acme.features.market.fruit.domain.model.FruitRef;

import jakarta.enterprise.context.RequestScoped;
import jakarta.enterprise.event.Event;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.ToString;
import lombok.experimental.SuperBuilder;

@RequestScoped
@RequiredArgsConstructor
public class FruitsVisibilityService {

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  @SuperBuilder(toBuilder = true)
  @Getter
  @EqualsAndHashCode(callSuper = true, onlyExplicitlyIncluded = true)
  @ToString
  public static class FruitFixedFields extends Interaction {

    /**
     * The list of fixed fields
     *
     * @autogenerated VisibilityServiceGenerator
     */
    @NonNull
    private Set<String> fixed;

    /**
     * @autogenerated VisibilityServiceGenerator
     */
    private FruitRef fruit;

    /**
     * Add another field to the fixed list
     *
     * @autogenerated VisibilityServiceGenerator
     * @param field A field to add to fixed
     */
    public void add(final String field) {
      fixedEditable().add(field);
    }

    /**
     * The self instance to chain other calls
     *
     * @autogenerated VisibilityServiceGenerator
     * @param field A field to add to fixed
     * @return The self instance to chain other calls
     */
    public FruitFixedFields and(final String field) {
      fixedEditable().add(field);
      return this;
    }

    /**
     * The iterable stream of fixed fields
     *
     * @autogenerated VisibilityServiceGenerator
     * @return The iterable stream of fixed fields
     */
    public Stream<String> getFixed() {
      return fixed.stream();
    }

    /**
     * @autogenerated VisibilityServiceGenerator
     * @return
     */
    public Optional<FruitRef> getFruit() {
      return Optional.ofNullable(fruit);
    }

    /**
     * The self instance to chain other calls
     *
     * @autogenerated VisibilityServiceGenerator
     * @param field A field to remote from fixed
     * @return The self instance to chain other calls
     */
    public FruitFixedFields not(final String field) {
      fixedEditable().remove(field);
      return this;
    }

    /**
     * Remove one field from the fixed list
     *
     * @autogenerated VisibilityServiceGenerator
     * @param field A field to remote from fixed
     */
    public void remove(final String field) {
      fixedEditable().remove(field);
    }

    /**
     * The list ensured as an editable list
     *
     * @autogenerated VisibilityServiceGenerator
     * @return The list ensured as an editable list
     */
    private Set<String> fixedEditable() {
      if (!(fixed instanceof LinkedHashSet)) {
        fixed = new LinkedHashSet<>(fixed);
      }
      return fixed;
    }
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  @SuperBuilder(toBuilder = true)
  @Getter
  @EqualsAndHashCode(callSuper = true, onlyExplicitlyIncluded = true)
  @ToString
  public static class FruitHiddenFields extends Interaction {

    /**
     * @autogenerated VisibilityServiceGenerator
     */
    private FruitRef fruit;

    /**
     * The list of hidden fields
     *
     * @autogenerated VisibilityServiceGenerator
     */
    @NonNull
    private Set<String> hidden;

    /**
     * Add another field to the hidden list
     *
     * @autogenerated VisibilityServiceGenerator
     * @param field A field to add to hidden
     */
    public void add(final String field) {
      hiddenEditable().add(field);
    }

    /**
     * The self instance to chain other calls
     *
     * @autogenerated VisibilityServiceGenerator
     * @param field A field to add to hidden
     * @return The self instance to chain other calls
     */
    public FruitHiddenFields and(final String field) {
      hiddenEditable().add(field);
      return this;
    }

    /**
     * @autogenerated VisibilityServiceGenerator
     * @return
     */
    public Optional<FruitRef> getFruit() {
      return Optional.ofNullable(fruit);
    }

    /**
     * The iterable stream of hidden fields
     *
     * @autogenerated VisibilityServiceGenerator
     * @return The iterable stream of hidden fields
     */
    public Stream<String> getHidden() {
      return hidden.stream();
    }

    /**
     * The self instance to chain other calls
     *
     * @autogenerated VisibilityServiceGenerator
     * @param field A field to remote from hidden
     * @return The self instance to chain other calls
     */
    public FruitHiddenFields not(final String field) {
      hiddenEditable().remove(field);
      return this;
    }

    /**
     * Remove one field from the hidden list
     *
     * @autogenerated VisibilityServiceGenerator
     * @param field A field to remote from hidden
     */
    public void remove(final String field) {
      hiddenEditable().remove(field);
    }

    /**
     * The list ensured as an editable list
     *
     * @autogenerated VisibilityServiceGenerator
     * @return The list ensured as an editable list
     */
    private Set<String> hiddenEditable() {
      if (!(hidden instanceof LinkedHashSet)) {
        hidden = new LinkedHashSet<>(hidden);
      }
      return hidden;
    }
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  public static class FruitListableContent extends ArrayList<Fruit> {

    /**
     * Native serialization control
     *
     * @autogenerated VisibilityServiceGenerator
     */
    static final long serialVersionUID = 342985677l;

    /**
     * @autogenerated VisibilityServiceGenerator
     * @param c
     */
    FruitListableContent(final Collection<? extends Fruit> c) {
      super(c);
    }
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  public static class FruitVisibleList extends ArrayList<Fruit> {

    /**
     * Native serialization control
     *
     * @autogenerated VisibilityServiceGenerator
     */
    static final long serialVersionUID = 1486884964l;

    /**
     * @autogenerated VisibilityServiceGenerator
     * @param c
     */
    FruitVisibleList(final Collection<? extends Fruit> c) {
      super(c);
    }
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final Fruits aggregate;

  /**
   * Event source for maniputale the fix over the entity fields
   *
   * @autogenerated VisibilityServiceGenerator
   */
  private final Event<FruitFixedFields> fireFix;

  /**
   * Event source for maniputale the hide over the entity fields
   *
   * @autogenerated VisibilityServiceGenerator
   */
  private final Event<FruitHiddenFields> fireHide;

  /**
   * Event source for maniputale the visible list
   *
   * @autogenerated VisibilityServiceGenerator
   */
  private final Event<FruitListableContent> fireListableList;

  /**
   * Event source for maniputale the visibility filter over the entity fields
   *
   * @autogenerated VisibilityServiceGenerator
   */
  private final Event<FruitFilter> fireVisibleFilter;

  /**
   * Event source for maniputale the visible list
   *
   * @autogenerated VisibilityServiceGenerator
   */
  private final Event<FruitVisibleList> fireVisibleList;

  /**
   * The input entity with the copy values without hidden
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param original The source interaction
   * @param source The source interaction
   * @return The input entity with the copy values without hidden
   */
  public FruitDto copyWithFixed(Interaction prev, Fruit original, FruitDto source) {
    fieldsToFix(prev, original).getFixed().forEach(field -> source.fix(field, original));
    return source;
  }

  /**
   * The input entity with the copy values without hidden
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param source The source interaction
   * @return The input entity with the copy values without hidden
   */
  public FruitDto copyWithFixed(Interaction prev, FruitDto source) {
    fieldsToFix(prev).getFixed().forEach(field -> source.fix(field));
    return source;
  }

  /**
   * initialsFixFields
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @return initialsFixFields
   */
  public FruitFixedFields fieldsToFix(Interaction prev) {
    Set<String> fields = new HashSet<>(aggregate.calcultadFields());
    fields.addAll(fieldsToHide(prev).getHidden().toList());
    FruitFixedFields value = FruitFixedFields.builder().fixed(fields).build(prev);
    fireFix.fire(value);
    return value;
  }

  /**
   * initialsFixFields
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param fruit
   * @return initialsFixFields
   */
  public FruitFixedFields fieldsToFix(Interaction prev, FruitRef fruit) {
    Set<String> fields = new HashSet<>(fieldsToFix(prev).getFixed().toList());
    fields.addAll(fieldsToHide(prev, fruit).getHidden().toList());
    FruitFixedFields value = FruitFixedFields.builder().fixed(fields).fruit(fruit).build(prev);
    fireFix.fire(value);
    return value;
  }

  /**
   * initialsHideFields
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @return initialsHideFields
   */
  public FruitHiddenFields fieldsToHide(Interaction prev) {
    Set<String> fields = Set.of();
    FruitHiddenFields value = FruitHiddenFields.builder().hidden(fields).build(prev);
    fireHide.fire(value);
    return value;
  }

  /**
   * initialsHideFields
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param fruit
   * @return initialsHideFields
   */
  public FruitHiddenFields fieldsToHide(Interaction prev, FruitRef fruit) {
    Set<String> fields = new HashSet<>(this.fieldsToHide(prev).getHidden().toList());
    FruitHiddenFields value = FruitHiddenFields.builder().hidden(fields).fruit(fruit).build(prev);
    fireHide.fire(value);
    return value;
  }

  /**
   * The input dto with hidden values
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param fruit
   * @return The input dto with hidden values
   */
  public FruitDto hide(Interaction prev, Fruit fruit) {
    FruitDto target = FruitDto.from(fruit);
    fieldsToHide(prev, fruit).getHidden().forEach(target::hide);
    return target;
  }

  /**
   * The input dto with hidden values
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param fruitRefs The source interaction
   * @return The input dto with hidden values
   */
  public List<Fruit> listableFilter(Interaction prev, Collection<? extends Fruit> fruitRefs) {
    FruitListableContent list = new FruitListableContent(visibleFilter(prev, fruitRefs));
    fireListableList.fire(list);
    return list;
  }

  /**
   * The input dto with hidden values
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param fruitRefs The source interaction
   * @return The input dto with hidden values
   */
  public List<Fruit> visibleFilter(Interaction prev, Collection<? extends Fruit> fruitRefs) {
    FruitVisibleList list = new FruitVisibleList(fruitRefs);
    fireVisibleList.fire(list);
    return list;
  }

  /**
   * The input dto with hidden values
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param fruitRef The source interaction
   * @return The input dto with hidden values
   */
  public Optional<Fruit> visibleFilter(Interaction prev, Fruit fruitRef) {
    FruitVisibleList list = new FruitVisibleList(List.of(fruitRef));
    fireVisibleList.fire(list);
    return list.isEmpty() ? Optional.empty() : Optional.of(list.get(0));
  }

  /**
   * The self filter modified with the prepared values.
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param filter The filter to retrieve values
   * @return The self filter modified with the prepared values.
   */
  public FruitFilter visibleFilter(Interaction prev, FruitFilter filter) {
    fireVisibleFilter.fire(filter);
    return filter;
  }
}
