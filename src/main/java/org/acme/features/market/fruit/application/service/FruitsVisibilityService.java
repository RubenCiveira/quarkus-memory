package org.acme.features.market.fruit.application.service;

import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;

import org.acme.common.action.Interaction;
import org.acme.common.reactive.Stream;
import org.acme.features.market.fruit.application.FruitDto;
import org.acme.features.market.fruit.application.service.event.FruitFixedFieldsPipelineStageEvent;
import org.acme.features.market.fruit.application.service.event.FruitHiddenFieldsPipelineStageEvent;
import org.acme.features.market.fruit.application.service.event.FruitVisibilityQueryPipelineStageEvent;
import org.acme.features.market.fruit.application.service.event.FruitVisibleContentPipelineStageEvent;
import org.acme.features.market.fruit.domain.Fruits;
import org.acme.features.market.fruit.domain.gateway.FruitCacheGateway;
import org.acme.features.market.fruit.domain.gateway.FruitCached;
import org.acme.features.market.fruit.domain.gateway.FruitCursor;
import org.acme.features.market.fruit.domain.gateway.FruitFilter;
import org.acme.features.market.fruit.domain.gateway.FruitReadRepositoryGateway;
import org.acme.features.market.fruit.domain.model.Fruit;
import org.acme.features.market.fruit.domain.model.FruitRef;

import io.opentelemetry.api.trace.Span;
import io.opentelemetry.api.trace.StatusCode;
import io.opentelemetry.api.trace.Tracer;
import io.opentelemetry.context.Scope;
import jakarta.enterprise.context.RequestScoped;
import jakarta.enterprise.event.Event;
import lombok.RequiredArgsConstructor;

@RequestScoped
@RequiredArgsConstructor
public class FruitsVisibilityService {

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final Fruits aggregate;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final FruitCacheGateway cache;

  /**
   * Event source for maniputale the fix over the entity fields
   *
   * @autogenerated VisibilityServiceGenerator
   */
  private final Event<FruitFixedFieldsPipelineStageEvent> fireFix;

  /**
   * Event source for maniputale the hide over the entity fields
   *
   * @autogenerated VisibilityServiceGenerator
   */
  private final Event<FruitHiddenFieldsPipelineStageEvent> fireHide;

  /**
   * Event source for maniputale the visibility filter over the entity fields
   *
   * @autogenerated VisibilityServiceGenerator
   */
  private final Event<FruitVisibilityQueryPipelineStageEvent> fireVisibleFilter;

  /**
   * Event source for maniputale the visible list
   *
   * @autogenerated VisibilityServiceGenerator
   */
  private final Event<FruitVisibleContentPipelineStageEvent> fireVisibleList;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final FruitsFormulaService formula;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final FruitReadRepositoryGateway fruitReadRepositoryGateway;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final Tracer tracer;

  /**
   * The input entity with the copy values without hidden
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param uid
   * @return The input entity with the copy values without hidden
   */
  public Stream<Boolean> checkVisibility(Interaction prev, String uid) {
    return retrieveVisible(prev, uid).isEmpty();
  }

  /**
   * The input entity with the copy values without hidden
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param uids
   * @return The input entity with the copy values without hidden
   */
  public CompletionStage<Boolean> checkVisibility(Interaction prev, List<String> uids) {
    Span startSpan = tracer.spanBuilder("fruit-check-item-visbility").startSpan();
    try (Scope scope = startSpan.makeCurrent()) {
      return listVisibles(prev, FruitFilter.builder().uids(uids).build(),
          FruitCursor.builder().build()).thenApply(list -> list.size() == uids.size())
              .whenComplete((val, ex) -> {
                if (null == ex) {
                  startSpan.setStatus(StatusCode.OK);
                } else {
                  startSpan.recordException(ex).setStatus(StatusCode.ERROR);
                }
                startSpan.end();
              });
    }
  }

  /**
   * The input entity with the copy values without hidden
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param original The source interaction
   * @param source The source interaction
   * @return The input entity with the copy values without hidden
   */
  public CompletionStage<FruitDto> copyWithFixed(Interaction prev, Fruit original,
      FruitDto source) {
    Span startSpan = tracer.spanBuilder("fruit-copy-existent-with-fixed").startSpan();
    try (Scope scope = startSpan.makeCurrent()) {
      return fieldsToFix(prev, original).thenApply(fixeds -> {
        fixeds.forEach(field -> source.fixField(field, original));
        return source;
      }).thenCompose(fixed -> formula.copyWithFormulas(prev, original, fixed))
          .whenComplete((val, ex) -> {
            if (null == ex) {
              startSpan.setStatus(StatusCode.OK);
            } else {
              startSpan.recordException(ex).setStatus(StatusCode.ERROR);
            }
            startSpan.end();
          });
    }
  }

  /**
   * The input entity with the copy values without hidden
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param source The source interaction
   * @return The input entity with the copy values without hidden
   */
  public CompletionStage<FruitDto> copyWithFixed(Interaction prev, FruitDto source) {
    Span startSpan = tracer.spanBuilder("fruit-copy-new-with-fixed").startSpan();
    try (Scope scope = startSpan.makeCurrent()) {
      return fieldsToFix(prev).thenApply(fixeds -> {
        fixeds.forEach(field -> source.fixField(field));
        return source;
      }).thenCompose(fixed -> formula.copyWithFormulas(prev, fixed)).whenComplete((val, ex) -> {
        if (null == ex) {
          startSpan.setStatus(StatusCode.OK);
        } else {
          startSpan.recordException(ex).setStatus(StatusCode.ERROR);
        }
        startSpan.end();
      });
    }
  }

  /**
   * The input dto with hidden values
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param fruit
   * @return The input dto with hidden values
   */
  public CompletionStage<FruitDto> copyWithHidden(Interaction prev, Fruit fruit) {
    Span startSpan = tracer.spanBuilder("fruit-copy-with-hidden").startSpan();
    try (Scope scope = startSpan.makeCurrent()) {
      return fieldsToHide(prev, fruit).thenApply(hidden -> {
        FruitDto target = FruitDto.from(fruit);
        hidden.forEach(target::hideField);
        return target;
      }).whenComplete((val, ex) -> {
        if (null == ex) {
          startSpan.setStatus(StatusCode.OK);
        } else {
          startSpan.recordException(ex).setStatus(StatusCode.ERROR);
        }
        startSpan.end();
      });
    }
  }

  /**
   * initialsFixFields
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @return initialsFixFields
   */
  public CompletionStage<Set<String>> fieldsToFix(Interaction prev) {
    Span startSpan = tracer.spanBuilder("fruit-field-to-fix-for-new").startSpan();
    try (Scope scope = startSpan.makeCurrent()) {
      CompletionStage<Set<String>> fields = fieldsToHide(prev).thenApply(hidden -> {
        Set<String> set = new HashSet<>(aggregate.calcultadFields());
        set.addAll(hidden);
        return set;
      });
      FruitFixedFieldsPipelineStageEvent value =
          FruitFixedFieldsPipelineStageEvent.builder().fields(fields).query(prev).build();
      fireFix.fire(value);
      return value.getFields().whenComplete((val, ex) -> {
        if (null == ex) {
          startSpan.setAttribute("fieds", String.join(",", val));
          startSpan.setStatus(StatusCode.OK);
        } else {
          startSpan.recordException(ex).setStatus(StatusCode.ERROR);
        }
        startSpan.end();
      });
    }
  }

  /**
   * initialsFixFields
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param fruit
   * @return initialsFixFields
   */
  public CompletionStage<Set<String>> fieldsToFix(Interaction prev, FruitRef fruit) {
    Span startSpan = tracer.spanBuilder("fruit-field-to-fix-for-existent").startSpan();
    try (Scope scope = startSpan.makeCurrent()) {
      CompletionStage<Set<String>> fields =
          fieldsToFix(prev).thenCombine(fieldsToHide(prev, fruit), (set1, set2) -> {
            Set<String> set = new HashSet<>(set1);
            set.addAll(set2);
            return set;
          });
      FruitFixedFieldsPipelineStageEvent value = FruitFixedFieldsPipelineStageEvent.builder()
          .fields(fields).fruit(fruit).query(prev).build();
      fireFix.fire(value);
      return value.getFields().whenComplete((val, ex) -> {
        if (null == ex) {
          startSpan.setAttribute("fieds", String.join(",", val));
          startSpan.setStatus(StatusCode.OK);
        } else {
          startSpan.recordException(ex).setStatus(StatusCode.ERROR);
        }
        startSpan.end();
      });
    }
  }

  /**
   * initialsHideFields
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @return initialsHideFields
   */
  public CompletionStage<Set<String>> fieldsToHide(Interaction prev) {
    Span startSpan = tracer.spanBuilder("fruit-field-to-hide-for-new").startSpan();
    try (Scope scope = startSpan.makeCurrent()) {
      CompletionStage<Set<String>> fields = CompletableFuture.completedFuture(Set.of());
      FruitHiddenFieldsPipelineStageEvent value =
          FruitHiddenFieldsPipelineStageEvent.builder().fields(fields).query(prev).build();
      fireHide.fire(value);
      return value.getFields().whenComplete((val, ex) -> {
        if (null == ex) {
          startSpan.setAttribute("fieds", String.join(",", val));
          startSpan.setStatus(StatusCode.OK);
        } else {
          startSpan.recordException(ex).setStatus(StatusCode.ERROR);
        }
        startSpan.end();
      });
    }
  }

  /**
   * initialsHideFields
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param fruit
   * @return initialsHideFields
   */
  public CompletionStage<Set<String>> fieldsToHide(Interaction prev, FruitRef fruit) {
    Span startSpan = tracer.spanBuilder("fruit-field-to-hide-for-existent").startSpan();
    try (Scope scope = startSpan.makeCurrent()) {
      CompletionStage<Set<String>> fields = fieldsToHide(prev);
      FruitHiddenFieldsPipelineStageEvent value = FruitHiddenFieldsPipelineStageEvent.builder()
          .fields(fields).fruit(fruit).query(prev).build();
      fireHide.fire(value);
      return value.getFields().whenComplete((val, ex) -> {
        if (null == ex) {
          startSpan.setAttribute("fieds", String.join(",", val));
          startSpan.setStatus(StatusCode.OK);
        } else {
          startSpan.recordException(ex).setStatus(StatusCode.ERROR);
        }
        startSpan.end();
      });
    }
  }

  /**
   * The input entity with the copy values without hidden
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param filter The filter to retrieve values
   * @param cursor The filter to retrieve values
   * @return The input entity with the copy values without hidden
   */
  public Stream<FruitCached> listCachedVisibles(Interaction prev, FruitFilter filter,
      FruitCursor cursor) {
    
    
      return applyPreVisibilityFilter(prev, filter)
          .flatMap(visfilter -> cache.retrieve(visfilter, cursor)
              .ifEmpty(() -> {
                queryItems(prev, filter, cursor);
                Stream<FruitCached> all = queryItems(prev, filter, cursor).all(values -> {
                  Stream<FruitCached> map = cache.store(filter, cursor, values).map(cached -> {
                    return FruitCached.builder().value(values).since(OffsetDateTime.now()).build();
                  });
                  return map;
                });
                return all;
              }) );
  }

  /**
   * The input entity with the copy values without hidden
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param filter The filter to retrieve values
   * @param cursor The filter to retrieve values
   * @return The input entity with the copy values without hidden
   */
  public Stream<Fruit> listVisibles(Interaction prev, FruitFilter filter,
      FruitCursor cursor) {
      return applyPreVisibilityFilter(prev, filter)
          .flatMap(visfilter -> queryItems(prev, visfilter, cursor));
  }

  /**
   * The input entity with the copy values without hidden
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param uid
   * @return The input entity with the copy values without hidden
   */
  public CompletionStage<FruitCached> retrieveCachedVisible(Interaction prev, String uid) {
    Span startSpan = tracer.spanBuilder("fruit-retrieve-cached-visible").startSpan();
    try (Scope scope = startSpan.makeCurrent()) {
      return applyPreVisibilityFilter(prev, FruitFilter.builder().uid(uid).build())
          .thenCompose(filter -> {
            filter.setUid(uid);
            FruitCursor cursor = FruitCursor.builder().limit(1).build();
            return cache.retrieve(filter, cursor).thenCompose(cached -> {
              if (cached.isPresent()) {
                startSpan.setAttribute("source", "cache");
                return CompletableFuture.completedStage(cached.get());
              } else {
                startSpan.setAttribute("source", "gateway");
                return queryItem(prev, uid, filter).thenApply(value -> {
                  List<Fruit> values = value.map(List::of).orElseGet(List::of);
                  cache.store(filter, cursor, values);
                  return FruitCached.builder().value(values).since(OffsetDateTime.now()).build();
                });
              }
            });
          }).whenComplete((val, ex) -> {
            if (null == ex) {
              startSpan.setStatus(StatusCode.OK);
            } else {
              startSpan.recordException(ex).setStatus(StatusCode.ERROR);
            }
            startSpan.end();
          });
    }
  }

  /**
   * The input entity with the copy values without hidden
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param uid
   * @return The input entity with the copy values without hidden
   */
  public Stream<Fruit> retrieveVisible(Interaction prev, String uid) {
    Span startSpan = tracer.spanBuilder("fruit-retrieve-visible").startSpan();
    try (Scope scope = startSpan.makeCurrent()) {
      return applyPreVisibilityFilter(prev, FruitFilter.builder().uid(uid).build())
          .flatMap(filter -> queryItem(prev, uid, filter));
    }
  }

  /**
   * The self filter modified with the prepared values.
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param filter The filter to retrieve values
   * @return The self filter modified with the prepared values.
   */
  private Stream<FruitFilter> applyPreVisibilityFilter(Interaction prev, FruitFilter filter) {
    Span startSpan = tracer.spanBuilder("fruit-calculate-visible-filter").startSpan();
    try (Scope scope = startSpan.makeCurrent()) {
      FruitVisibilityQueryPipelineStageEvent visible = FruitVisibilityQueryPipelineStageEvent
          .builder().filter(Stream.just(filter)).interaction(prev).build();
      fireVisibleFilter.fire(visible);
      return visible.getFilter();
    }
  }

  /**
   * The input dto with hidden values
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param fruitRefs The source interaction
   * @return The input dto with hidden values
   */
  private Stream<Fruit> evaluatePostVisibility(Interaction prev, Stream<Fruit> fruitRefs) {
    return fruitRefs.filter(item -> evaluatePostVisibility(prev, item));
  }

  /**
   * The input dto with hidden values
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param fruitRef The source interaction
   * @return The input dto with hidden values
   */
  private Stream<Boolean> evaluatePostVisibility(Interaction prev, Fruit fruitRef) {
    FruitVisibleContentPipelineStageEvent list = FruitVisibleContentPipelineStageEvent.builder()
        .entity(fruitRef).visible(Stream.just(true)).interaction(prev).build();
    fireVisibleList.fire(list);
    return list.getVisible();
  }

  /**
   * The input entity with the copy values without hidden
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param uid
   * @param filter The filter to retrieve values
   * @return The input entity with the copy values without hidden
   */
  private Stream<Fruit> queryItem(Interaction prev, String uid, FruitFilter filter) {
    Span startSpan = tracer.spanBuilder("fruit-query-item").startSpan();
    try (Scope scope = startSpan.makeCurrent()) {
      return fruitReadRepositoryGateway.retrieve(uid, Optional.of(filter))
          .filter(values -> evaluatePostVisibility(prev, values));
    }
  }

  /**
   * The input entity with the copy values without hidden
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param filter The filter to retrieve values
   * @param cursor The filter to retrieve values
   * @return The input entity with the copy values without hidden
   */
  private Stream<Fruit> queryItems(Interaction prev, FruitFilter filter, FruitCursor cursor) {
    return fruitReadRepositoryGateway.list(filter, cursor)
        .slide(values -> evaluatePostVisibility(prev, values));
  }
}
