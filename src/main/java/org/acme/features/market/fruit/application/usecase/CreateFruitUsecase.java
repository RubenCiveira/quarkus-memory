package org.acme.features.market.fruit.application.usecase;

import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;

import org.acme.common.exception.NotAllowedException;
import org.acme.features.market.fruit.application.allow.FruitCreateAllow;
import org.acme.features.market.fruit.application.interaction.FruitDto;
import org.acme.features.market.fruit.application.interaction.command.FruitCreateCommand;
import org.acme.features.market.fruit.application.interaction.query.FruitAllowQuery;
import org.acme.features.market.fruit.application.interaction.result.FruitCreateResult;
import org.acme.features.market.fruit.application.usecase.service.FruitsVisibilityService;
import org.acme.features.market.fruit.domain.Fruits;
import org.acme.features.market.fruit.domain.gateway.FruitFilter;
import org.acme.features.market.fruit.domain.gateway.FruitWriteRepositoryGateway;
import org.acme.features.market.fruit.domain.model.Fruit;

import jakarta.enterprise.context.RequestScoped;
import jakarta.enterprise.event.Event;
import lombok.RequiredArgsConstructor;

@RequestScoped
@RequiredArgsConstructor
public class CreateFruitUsecase {

  /**
   * @autogenerated CreateUsecaseGenerator
   */
  private final Fruits aggregate;

  /**
   * Event source for maniputale the visibility filter over the entity fields
   *
   * @autogenerated CreateUsecaseGenerator
   */
  private final Event<FruitCreateAllow> createAllow;

  /**
   * @autogenerated CreateUsecaseGenerator
   */
  private final FruitWriteRepositoryGateway gateway;

  /**
   * @autogenerated CreateUsecaseGenerator
   */
  private final FruitsVisibilityService visibility;

  /**
   * @autogenerated CreateUsecaseGenerator
   * @param query
   * @return
   */
  public FruitCreateAllow allow(final FruitAllowQuery query) {
    FruitCreateAllow base = FruitCreateAllow.build(true, "Allowed by default");
    createAllow.fire(base);
    return base;
  }

  /**
   * The slide with some values
   *
   * @autogenerated CreateUsecaseGenerator
   * @param query a filter to retrieve only matching values
   * @return The slide with some values
   */
  public FruitCreateResult create(final FruitCreateCommand query) {
    CompletionStage<Optional<Fruit>> create = allow(query).getDetail().thenCompose(detail -> {
      if (!detail.isAllowed()) {
        throw new NotAllowedException(detail.getDescription());
      }
      return visibility.copyWithFixed(query, query.getDto())
          .thenCompose(builder -> aggregate.initialize(builder.toEntityBuilder())
              .thenCompose(fruitEntity -> createAndVerify(query, fruitEntity)));
    });
    return FruitCreateResult.builder().command(query)
        .fruit(create.thenCompose(fruit -> mapEntity(query, fruit))).build();
  }

  /**
   * @autogenerated CreateUsecaseGenerator
   * @param query
   * @return
   */
  private FruitCreateAllow allow(final FruitCreateCommand query) {
    return allow(FruitAllowQuery.builder().build(query));
  }

  /**
   * @autogenerated CreateUsecaseGenerator
   * @param query
   * @param fruitEntity
   * @return
   */
  private CompletionStage<Optional<Fruit>> createAndVerify(final FruitCreateCommand query,
      final Fruit fruitEntity) {
    return gateway.create(fruitEntity, created -> verifyCreation(query, created));
  }

  /**
   * The slide with some values
   *
   * @autogenerated CreateUsecaseGenerator
   * @param command a filter to retrieve only matching values
   * @param opfruit
   * @return The slide with some values
   */
  private CompletionStage<Optional<FruitDto>> mapEntity(final FruitCreateCommand command,
      final Optional<Fruit> opfruit) {
    return opfruit.map(fruit -> visibility.hide(command, fruit).thenApply(Optional::of))
        .orElseGet(() -> CompletableFuture.completedFuture(Optional.empty()));
  }

  /**
   * @autogenerated CreateUsecaseGenerator
   * @param query
   * @param created
   * @return
   */
  private CompletionStage<Boolean> verifyCreation(final FruitCreateCommand query,
      final Fruit created) {
    FruitFilter filter = FruitFilter.builder().uid(created.getUidValue()).build();
    return visibility.visibleFilter(query, filter).thenCompose(
        visibleFilter -> gateway.exists(created.getUidValue(), Optional.of(visibleFilter)));
  }
}
