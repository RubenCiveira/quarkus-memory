package org.acme.features.market.fruit.application.dto;

import java.util.Optional;

import org.acme.common.action.Interaction;
import org.acme.features.market.fruit.domain.Fruits;
import org.acme.features.market.fruit.domain.FruitsVisibility;
import org.acme.features.market.fruit.domain.gateway.FruitRepositoryGateway;
import org.acme.features.market.fruit.domain.interaction.FruitDto;
import org.acme.features.market.fruit.domain.interaction.FruitFilter;
import org.acme.features.market.fruit.domain.interaction.command.FruitCreateCommand;
import org.acme.features.market.fruit.domain.interaction.query.FruitListQuery;
import org.acme.features.market.fruit.domain.interaction.query.FruitRetrieveQuery;
import org.acme.features.market.fruit.domain.interaction.result.FruitCreateResult;
import org.acme.features.market.fruit.domain.interaction.result.FruitListResult;
import org.acme.features.market.fruit.domain.interaction.result.FruitRetrieveResult;
import org.acme.features.market.fruit.domain.model.Fruit;

import io.smallrye.mutiny.Uni;
import jakarta.enterprise.context.RequestScoped;
import lombok.RequiredArgsConstructor;

@RequestScoped
@RequiredArgsConstructor
public class FruitsUsecase {
  /**
   * The source of truth with the data
   *
   * @autogenerated ListTraitGenerator
   */
  private final FruitRepositoryGateway gateway;

  /**
   * The event source for control editable and visible fields
   *
   * @autogenerated ListTraitGenerator
   */
  private final FruitsVisibility visibility;

  /**
   * The event source for control editable and visible fields
   *
   * @autogenerated ListTraitGenerator
   */
  private final Fruits fruits;

  /**
   * The slide with some values
   *
   * @autogenerated CreateTraitGenerator
   * @param command a filter to retrieve only matching values
   * @return The slide with some values
   */
  public Uni<FruitCreateResult> create(final FruitCreateCommand command) {
    Fruit entity =
        fruits.initialize(command, visibility.copyWithfixed(command, null, command.getDto()));
    return gateway.create(entity).flatMap(result -> checkIfIsVisible(command, entity));
  }

  private Uni<FruitCreateResult> checkIfIsVisible(final FruitCreateCommand command, Fruit entity) {
    return gateway
        .retrieve(visibility.visibleFilter(command,
            FruitFilter.builder().uid(entity.getUid().getValue()).build()))
        .flatMap(visible -> visible.isPresent() ? returnValue(command, visible)
            : removeAndReturn(command, entity));
  }

  private Uni<FruitCreateResult> returnValue(FruitCreateCommand command, Optional<Fruit> dto) {
    return Uni.createFrom()
        .item(FruitCreateResult.fromDto(command, prepareEntityValue(command, dto)));
  }
  
  private Uni<FruitCreateResult> removeAndReturn(FruitCreateCommand command, Fruit entity) {
    return gateway.rollback(entity).map(empt -> FruitCreateResult.from(command, Optional.empty()));
  }
  
  /**
   * The slide with some values
   *
   * @autogenerated ListTraitGenerator
   * @param query a filter to retrieve only matching values
   * @return The slide with some values
   */
  public Uni<FruitListResult> list(final FruitListQuery query) {
    return gateway.list(visibility.visibleFilter(query, query.getFilter()), query.getCursor())
        .flatMap(slide -> fruits.prepareOutputValue(query, slide));
  }

  /**
   * The slide with some values
   *
   * @autogenerated RetrieveTraitGenerator
   * @param query a filter to retrieve only matching values
   * @return The slide with some values
   */
  public Uni<FruitRetrieveResult> retrieve(final FruitRetrieveQuery query) {
    return gateway
        .retrieve(
            visibility.visibleFilter(query, FruitFilter.builder().uid(query.getUid()).build()))
        .map(optional -> FruitRetrieveResult.fromDto(query, prepareEntityValue(query, optional)));
  }

  private Optional<FruitDto> prepareEntityValue(Interaction interaction, Optional<Fruit> fruit) {
    return fruits.prepareOutputValue(interaction, fruit.map(FruitDto::from));
  }
}
