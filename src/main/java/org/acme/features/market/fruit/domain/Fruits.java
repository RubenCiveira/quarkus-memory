package org.acme.features.market.fruit.domain;

import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.function.BiFunction;

import org.acme.common.action.ParametrizedPipeline;
import org.acme.common.action.PriorityComparator;
import org.acme.features.market.fruit.domain.model.Fruit;
import org.acme.features.market.fruit.domain.model.Fruit.FruitBuilder;
import org.acme.features.market.fruit.domain.rule.FruitActionType;
import org.acme.features.market.fruit.domain.rule.FruitBuilderRule;
import org.acme.features.market.fruit.domain.rule.FruitRule;

import jakarta.enterprise.context.RequestScoped;
import jakarta.enterprise.inject.Instance;

@RequestScoped
public class Fruits {

  /**
   * @autogenerated AggregateGenerator
   */
  private final ParametrizedPipeline<FruitBuilder, FruitActionType, Optional<Fruit>> builderRules;

  /**
   * @autogenerated AggregateGenerator
   */
  private final ParametrizedPipeline<Fruit, FruitActionType, Optional<Fruit>> rules;

  /**
   * @autogenerated AggregateGenerator
   */
  private Map<String, BiFunction<FruitBuilder, Optional<Fruit>, FruitBuilder>> calculatedFields =
      Map.of();

  /**
   * @autogenerated AggregateGenerator
   * @param rules
   * @param builderRules
   */
  public Fruits(final Instance<FruitRule> rules, final Instance<FruitBuilderRule> builderRules) {
    this.rules = new ParametrizedPipeline<>(FruitActionType.values(), rules.stream().toList(),
        new PriorityComparator<>());
    this.builderRules = new ParametrizedPipeline<>(FruitActionType.values(),
        builderRules.stream().toList(), new PriorityComparator<>());
  }

  /**
   * @autogenerated AggregateGenerator
   * @return
   */
  public Set<String> calcultadFields() {
    return calculatedFields.keySet();
  }

  /**
   * The entity
   *
   * @autogenerated AggregateGenerator
   * @param entity a filter to retrieve only matching values
   * @return The entity
   */
  public Fruit clean(final Fruit entity) {
    return rules.apply(FruitActionType.DELETE, entity, Optional.of(entity));
  }

  /**
   * The entity
   *
   * @autogenerated AggregateGenerator
   * @param builder a filter to retrieve only matching values
   * @return The entity
   */
  public Fruit initialize(final FruitBuilder builder) {
    Optional<Fruit> original = Optional.empty();
    FruitBuilder ruledBuilder = this.builderRules.apply(FruitActionType.CREATE, builder, original);
    for (BiFunction<FruitBuilder, Optional<Fruit>, FruitBuilder> callback : calculatedFields
        .values()) {
      ruledBuilder = callback.apply(ruledBuilder, original);
    }
    return rules.apply(FruitActionType.CREATE, ruledBuilder.build(), original);
  }

  /**
   * The entity
   *
   * @autogenerated AggregateGenerator
   * @param base a filter to retrieve only matching values
   * @param builder a filter to retrieve only matching values
   * @return The entity
   */
  public Fruit modify(final Fruit base, final FruitBuilder builder) {
    Optional<Fruit> original = Optional.of(base);
    FruitBuilder ruledBuilder = this.builderRules.apply(FruitActionType.UPDATE, builder, original);
    for (BiFunction<FruitBuilder, Optional<Fruit>, FruitBuilder> callback : calculatedFields
        .values()) {
      ruledBuilder = callback.apply(ruledBuilder, original);
    }
    return rules.apply(FruitActionType.UPDATE, ruledBuilder.build(), original);
  }
}
