package org.acme.features.market.fruit.domain;

import java.util.List;
import java.util.Optional;

import org.acme.common.action.Interaction;
import org.acme.common.action.Slide;
import org.acme.features.market.fruit.domain.gateway.FruitRepositoryGateway;
import org.acme.features.market.fruit.domain.interaction.FruitDto;
import org.acme.features.market.fruit.domain.interaction.query.ListQuery;
import org.acme.features.market.fruit.domain.interaction.result.ListResult;
import org.acme.features.market.fruit.domain.interaction.result.RetrieveResult;
import org.acme.features.market.fruit.domain.model.Fruit;

import io.smallrye.mutiny.Uni;
import jakarta.enterprise.context.RequestScoped;
import lombok.RequiredArgsConstructor;

@RequestScoped
@RequiredArgsConstructor
public class Fruits {

  /**
   * The event source to allow customization
   *
   * @autogenerated ListTraitGenerator
   */
  private final FruitsEvent events;

  /**
   * The source of truth with the data
   *
   * @autogenerated ListTraitGenerator
   */
  private final FruitRepositoryGateway gateway;

  /**
   * The event source for control editable and visible fields
   *
   * @autogenerated ListTraitGenerator
   */
  private final FruitsVisibility visibility;

  /**
   * The slide with some values
   *
   * @autogenerated ListTraitGenerator
   * @param query a filter to retrieve only matching values
   * @return The slide with some values
   */
  public Uni<ListResult> list(final ListQuery query) {
    return gateway.list(visibility.visibleFilter(query, query.getFilter()), query.getCursor())
        .flatMap(slide -> this.filterAndFill(slide, query));
  }

  /**
   * The slide with some values
   *
   * @autogenerated ListTraitGenerator
   * @param slide
   * @param query a filter to retrieve only matching values
   * @return The slide with some values
   */
  private Uni<ListResult> filterAndFill(final Slide<Fruit> slide, final ListQuery query) {
    return slide
        .filterAndFill(query.getCursor().getLimit(), fruits -> retainSlideValues(query, fruits))
        .map(list -> ListResult.fromDto(query, list))
        .invoke(result -> prepareOutputValue(query, result));
  }

  /**
   * The preserved values after the event (dtos)
   *
   * @autogenerated ListTraitGenerator
   * @param query The interaction that provoques the list
   * @param fruits The dto with all the values, to be prepared for user of the interaction
   * @return The preserved values after the event (dtos)
   */
  private ListResult prepareOutputValue(final Interaction query, final ListResult fruits) {
    fruits.getFruits().forEach(fruit -> prepareOutputValue(query, Optional.of(fruit)));
    return fruits;
  }

  /**
   * The self dto, with all the notifications and the data ready
   *
   * @autogenerated RetrieveTraitGenerator
   * @param query The interaction that provoques the list
   * @param Fruit The dto with all the values, to be prepared for user of the interaction
   * @return The self dto, with all the notifications and the data ready
   */
  private Optional<FruitDto> prepareOutputValue(final Interaction query,
      final Optional<FruitDto> Fruit) {
    Optional<FruitDto> hidded = Fruit.map(original -> visibility.hide(query, original));
    return events.fireFruitRetrieveResult(RetrieveResult.fromDto(query, hidded)).getFruit();
  }

  /**
   * The preserved values after the event (dtos)
   *
   * @autogenerated ListTraitGenerator
   * @param query The interaction that provoques the list
   * @param fruits The raw current list data (entities)
   * @return The preserved values after the event (dtos)
   */
  private List<FruitDto> retainSlideValues(final Interaction query, final List<Fruit> fruits) {
    return events.fireFruitListResult(ListResult.from(query, fruits)).getFruits();
  }
}
