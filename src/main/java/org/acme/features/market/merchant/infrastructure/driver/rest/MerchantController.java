package org.acme.features.market.merchant.infrastructure.driver.rest;

import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import org.acme.common.security.Actor;
import org.acme.common.security.Connection;
import org.acme.features.market.merchant.application.interaction.MerchantDto;
import org.acme.features.market.merchant.application.interaction.command.MerchantCreateCommand;
import org.acme.features.market.merchant.application.interaction.command.MerchantDeleteCommand;
import org.acme.features.market.merchant.application.interaction.command.MerchantDisableCommand;
import org.acme.features.market.merchant.application.interaction.command.MerchantEnableCommand;
import org.acme.features.market.merchant.application.interaction.command.MerchantUpdateCommand;
import org.acme.features.market.merchant.application.interaction.query.MerchantListQuery;
import org.acme.features.market.merchant.application.interaction.query.MerchantRetrieveQuery;
import org.acme.features.market.merchant.application.interaction.result.MerchantCreateResult;
import org.acme.features.market.merchant.application.interaction.result.MerchantDeleteResult;
import org.acme.features.market.merchant.application.interaction.result.MerchantDisableResult;
import org.acme.features.market.merchant.application.interaction.result.MerchantEnableResult;
import org.acme.features.market.merchant.application.interaction.result.MerchantListResult;
import org.acme.features.market.merchant.application.interaction.result.MerchantRetrieveResult;
import org.acme.features.market.merchant.application.interaction.result.MerchantUpdateResult;
import org.acme.features.market.merchant.application.usecase.CreateMerchantUsecase;
import org.acme.features.market.merchant.application.usecase.DeleteMerchantUsecase;
import org.acme.features.market.merchant.application.usecase.DisableMerchantUsecase;
import org.acme.features.market.merchant.application.usecase.EnableMerchantUsecase;
import org.acme.features.market.merchant.application.usecase.ListMerchantUsecase;
import org.acme.features.market.merchant.application.usecase.RetrieveMerchantUsecase;
import org.acme.features.market.merchant.application.usecase.UpdateMerchantUsecase;
import org.acme.features.market.merchant.domain.gateway.MerchantCursor;
import org.acme.features.market.merchant.domain.gateway.MerchantFilter;
import org.acme.features.market.merchant.domain.gateway.MerchantOrder;
import org.acme.features.market.merchant.domain.model.MerchantReference;
import org.acme.generated.openapi.api.MerchantApi;
import org.acme.generated.openapi.model.Merchant;
import org.acme.generated.openapi.model.MerchantList;
import org.acme.generated.openapi.model.MerchantListNextOffset;

import jakarta.enterprise.context.RequestScoped;
import jakarta.ws.rs.core.Response;
import lombok.RequiredArgsConstructor;

@RequestScoped
@RequiredArgsConstructor
public class MerchantController implements MerchantApi {

  /**
   * @autogenerated ApiControllerGenerator
   */
  private final CreateMerchantUsecase create;

  /**
   * @autogenerated ApiControllerGenerator
   */
  private final DeleteMerchantUsecase delete;

  /**
   * @autogenerated ApiControllerGenerator
   */
  private final DisableMerchantUsecase disable;

  /**
   * @autogenerated ApiControllerGenerator
   */
  private final EnableMerchantUsecase enable;

  /**
   * @autogenerated ApiControllerGenerator
   */
  private final ListMerchantUsecase list;

  /**
   * @autogenerated ApiControllerGenerator
   */
  private final RetrieveMerchantUsecase retrieve;

  /**
   * @autogenerated ApiControllerGenerator
   */
  private final UpdateMerchantUsecase update;

  /**
   * @autogenerated ApiControllerGenerator
   * @param merchant
   * @return
   */
  @Override
  public Response merchantApiCreate(Merchant merchant) {
    Actor actor = new Actor();
    Connection connection = new Connection();
    MerchantDto dto = toDomainModel(merchant);
    MerchantCreateResult result = create.create(
        MerchantCreateCommand.builder().actor(actor).connection(connection).dto(dto).build());
    try {
      Optional<MerchantDto> outputMerchant =
          result.getMerchant().toCompletableFuture().get(1, TimeUnit.SECONDS);
      return outputMerchant.map(res -> Response.ok(toApiModel(res)).build())
          .orElseGet(() -> Response.status(404).build());
    } catch (InterruptedException | ExecutionException | TimeoutException e) {
      e.printStackTrace();
      return Response.serverError().build();
    }
  }

  /**
   * @autogenerated ApiControllerGenerator
   * @param uid
   * @return
   */
  @Override
  public Response merchantApiDelete(final String uid) {
    Actor actor = new Actor();
    Connection connection = new Connection();
    MerchantDeleteResult result = delete.delete(MerchantDeleteCommand.builder().actor(actor)
        .connection(connection).reference(MerchantReference.of(uid)).build());
    try {
      Optional<MerchantDto> merchant =
          result.getMerchant().toCompletableFuture().get(1, TimeUnit.SECONDS);
      return merchant.map(res -> Response.ok(toApiModel(res)).build())
          .orElseGet(() -> Response.status(404).build());
    } catch (InterruptedException | ExecutionException | TimeoutException e) {
      e.printStackTrace();
      return Response.serverError().build();
    }
  }

  /**
   * @autogenerated ApiControllerGenerator
   * @param uid
   * @return
   */
  @Override
  public Response merchantApiDisable(final String uid) {
    Actor actor = new Actor();
    Connection connection = new Connection();
    MerchantDisableResult result = disable.disable(MerchantDisableCommand.builder().actor(actor)
        .connection(connection).reference(MerchantReference.of(uid)).build());
    try {
      Optional<MerchantDto> outputMerchant =
          result.getMerchant().toCompletableFuture().get(1, TimeUnit.SECONDS);
      return outputMerchant.map(res -> Response.ok(toApiModel(res)).build())
          .orElseGet(() -> Response.status(404).build());
    } catch (InterruptedException | ExecutionException | TimeoutException e) {
      e.printStackTrace();
      return Response.serverError().build();
    }
  }

  /**
   * @autogenerated ApiControllerGenerator
   * @param uid
   * @return
   */
  @Override
  public Response merchantApiEnable(final String uid) {
    Actor actor = new Actor();
    Connection connection = new Connection();
    MerchantEnableResult result = enable.enable(MerchantEnableCommand.builder().actor(actor)
        .connection(connection).reference(MerchantReference.of(uid)).build());
    try {
      Optional<MerchantDto> outputMerchant =
          result.getMerchant().toCompletableFuture().get(1, TimeUnit.SECONDS);
      return outputMerchant.map(res -> Response.ok(toApiModel(res)).build())
          .orElseGet(() -> Response.status(404).build());
    } catch (InterruptedException | ExecutionException | TimeoutException e) {
      e.printStackTrace();
      return Response.serverError().build();
    }
  }

  /**
   * @autogenerated ApiControllerGenerator
   * @param uid
   * @param uids
   * @param search
   * @param enabled
   * @param limit
   * @param sinceUid
   * @param order
   * @return
   */
  @Override
  public Response merchantApiList(final String uid, final List<String> uids, final String search,
      final Boolean enabled, final Integer limit, final String sinceUid, final String order) {
    MerchantFilter.MerchantFilterBuilder filter = MerchantFilter.builder();
    MerchantCursor.MerchantCursorBuilder cursor = MerchantCursor.builder();
    cursor = cursor.limit(limit);
    cursor = cursor.sinceUid(sinceUid);
    filter = filter.uid(uid);
    filter = filter.uids(uids);
    filter = filter.search(search);
    filter = filter.enabled(enabled);
    if (null != order) {
      cursor = cursor.order(Arrays.asList(order.split(",")).stream().map(this::mapOrder)
          .filter(Objects::nonNull).toList());
    }
    Actor actor = new Actor();
    Connection connection = new Connection();
    MerchantListResult result = list.list(MerchantListQuery.builder().actor(actor)
        .connection(connection).filter(filter.build()).cursor(cursor.build()).build());
    try {
      List<MerchantDto> merchants =
          result.getMerchants().toCompletableFuture().get(1, TimeUnit.SECONDS);
      MerchantList res = new MerchantList();
      res.setContent(toApiModel(merchants));
      res.setNext(next(merchants));
      return Response.ok(res).build();
    } catch (InterruptedException | ExecutionException | TimeoutException e) {
      e.printStackTrace();
      return Response.serverError().build();
    }
  }

  /**
   * @autogenerated ApiControllerGenerator
   * @param uid
   * @return
   */
  @Override
  public Response merchantApiRetrieve(final String uid) {
    Actor actor = new Actor();
    Connection connection = new Connection();
    MerchantRetrieveResult result = retrieve.retrieve(MerchantRetrieveQuery.builder().actor(actor)
        .connection(connection).reference(MerchantReference.of(uid)).build());
    try {
      Optional<MerchantDto> merchant =
          result.getMerchant().toCompletableFuture().get(1, TimeUnit.SECONDS);
      return merchant.map(res -> Response.ok(toApiModel(res)).build())
          .orElseGet(() -> Response.status(404).build());
    } catch (InterruptedException | ExecutionException | TimeoutException e) {
      e.printStackTrace();
      return Response.serverError().build();
    }
  }

  /**
   * @autogenerated ApiControllerGenerator
   * @param uid
   * @param merchant
   * @return
   */
  @Override
  public Response merchantApiUpdate(final String uid, final Merchant merchant) {
    Actor actor = new Actor();
    Connection connection = new Connection();
    MerchantDto dto = toDomainModel(merchant);
    MerchantUpdateResult result = update.update(MerchantUpdateCommand.builder().actor(actor)
        .connection(connection).dto(dto).reference(MerchantReference.of(uid)).build());
    try {
      Optional<MerchantDto> outputMerchant =
          result.getMerchant().toCompletableFuture().get(1, TimeUnit.SECONDS);
      return outputMerchant.map(res -> Response.ok(toApiModel(res)).build())
          .orElseGet(() -> Response.status(404).build());
    } catch (InterruptedException | ExecutionException | TimeoutException e) {
      e.printStackTrace();
      return Response.serverError().build();
    }
  }

  /**
   * @autogenerated ApiControllerGenerator
   * @param label
   * @return
   */
  private MerchantOrder mapOrder(final String label) {
    if (null == label) {
      return null;
    } else if (label.trim().equals("name-asc")) {
      return MerchantOrder.NAME_ASC;
    } else if (label.trim().equals("name-desc")) {
      return MerchantOrder.NAME_DESC;
    } else {
      return null;
    }
  }

  /**
   * @autogenerated ApiControllerGenerator
   * @param list
   * @return
   */
  private MerchantListNextOffset next(List<MerchantDto> list) {
    if (list.isEmpty()) {
      return null;
    } else {
      MerchantListNextOffset next = new MerchantListNextOffset();
      MerchantDto last = list.get(list.size() - 1);
      next.setSinceUid(last.getUid());
      return next;
    }
  }

  /**
   * @autogenerated ApiControllerGenerator
   * @param merchants
   * @return
   */
  private List<Merchant> toApiModel(List<MerchantDto> merchants) {
    return merchants.stream().map(this::toApiModel).toList();
  }

  /**
   * @autogenerated ApiControllerGenerator
   * @param dto
   * @return
   */
  private Merchant toApiModel(MerchantDto dto) {
    Merchant merchant = new Merchant();
    merchant.setUid(dto.getUid());
    merchant.setName(dto.getName());
    merchant.setEnabled(dto.getEnabled());
    merchant.setKey(dto.getKey());
    merchant.setVersion(dto.getVersion());
    return merchant;
  }

  /**
   * @autogenerated ApiControllerGenerator
   * @param merchant
   * @return
   */
  private MerchantDto toDomainModel(Merchant merchant) {
    return MerchantDto.builder().uid(merchant.getUid()).name(merchant.getName())
        .enabled(merchant.getEnabled()).key(merchant.getKey()).version(merchant.getVersion())
        .build();
  }
}
